[TOC]

### 一  回顾Buffer Pool是什么？

在数据库中的Buffer Pool是一个非常关键的组件，因为数据库中的数据实际上最终都是要存放在磁盘文件上的，但是我们在对数据库执行增删改操作的时候，不可能直接更新磁盘上的数据的，因为如果你对磁盘进行**随机读写**操作，那速度是相当的慢，随便一个大磁盘文件的随机读写操作，可能都要几百毫秒。如果要是那么搞的话，可能你的数据库每秒也就只能处理几百个请求了！

因此，在对数据库执行增删改操作的时候，实际上主要都是针对内存里的Buffer Pool中的数据进行的，也就是你实际上主要是对数据库的内存里的数据结构进行了增删改，如下图所示。

<img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201104164408560.png" alt="image-20201104164408560" style="zoom: 33%;" />

但是在数据库的内存里执行了一堆增删改的操作，内存数据是更新了，但是这个时候如果数据库突然崩溃了，那么内存里更新好的数据不是都没了吗？

所以引入了一个redo log机制，你在对内存里的数据进行增删改的时候，他同时会把增删改对应的日志写入redo log文件中。

万一你的数据库突然崩溃了，没关系，只要从redo log日志文件里读取出来你之前做过哪些增删改操作，瞬间就可以重新把这些增删改操作在你的内存里执行一遍，这就可以恢复出来你之前做过哪些增删改操作了。

当然对于数据更新的过程，他是有一套严密的步骤的，还涉及到undo log、binlog、提交事务、buffer pool脏数据刷回磁盘，等等。

### 二  Buffer Pool内存数据结构

#### 1  如何配置你的Buffer Pool的大小？

首先我们来看看，我们应该如何配置你的Buffer Pool到底有多大呢？

因为Buffer Pool本质其实就是数据库的一个内存组件，你可以理解为他就是一片内存数据结构，所以这个内存数据结构肯定是有一定的大小的，不可能是无限大的。

这个Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整。比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存，使用下面的配置就可以了。

````xml
[server]
innodb_buffer_pool_size = 2147483648
````

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104164929824.png" alt="image-20201104164929824" style="zoom:33%;" />

#### 2  数据页：MySQL中抽象出来的数据单位

接着我们来看下一个问题，假设现在我们的数据库中一定有一片内存区域是Buffer Pool了，那么我们的数据是如何放在Buffer Pool中的？

实际上MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据。

所以实际上假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去也就是说，Buffer Pool中存放的是一个一个的数据页，如下图

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104171933881.png" alt="image-20201104171933881" style="zoom:33%;" />

#### 3  磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？

实际上默认情况下，磁盘中存放的数据页的大小是**16KB**，也就是说，一页数据包含了16KB的内容。而Buffer Pool中存放的一个一个的数据页，我们通常叫做**缓存页**，因为毕竟Buffer Pool是一个缓冲池，里面的数据都是从磁盘缓存到内存去的。而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。

####  4  缓存页对应的描述信息是什么？

接着我们要了解下一个概念，对于每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的，也可以叫做是控制数据，或者缓存页的元数据，比如包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂八的东西。

每个缓存页都会对应一个描述信息，这个描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。所以此时我们看下面的图，Buffer Pool实际看起来大概长这个样子。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104172854993.png" alt="image-20201104172854993" style="zoom:50%;" />

而且这里我们要注意一点，Buffer Pool中的描述数据大概相当于缓存页大小的5%左右，也就是每个描述数据大概是800个字节左右的大小，然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130多MB的样子，因为他里面还要存放每个缓存页的描述数据。

### 三  Buffer Pool数据处理流程 - free链表

#### 1  数据库启动的时候，是如何初始化Buffer Pool的？

数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区域，作为Buffer Pool的内存区域。

然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据。然后当数据库把Buffer Pool划分完毕之后，看起来就是之前我们看到的那张图了。

只不过这个时候，Buffer Pool中的一个一个的缓存页都是空的，里面什么都没有，要等数据库运行起来之后，当我们要对数据执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中。

#### 2  我们怎么知道哪些缓存页是空闲的呢？

接着我们来看下一个问题，当你的数据库运行起来之后，你肯定会不停的执行增删改查的操作，此时就需要不停的从磁盘上读取一个一个的数据页放入Buffer Pool中的对应的缓存页里去，把数据缓存起来，那么以后就可以对这个数据在内存里执行增删改查了。

但是此时在从磁盘上读取数据页放入Buffer Pool中的缓存页的时候，必然涉及到一个问题，那就是**哪些缓存页是空闲的？**

因为默认情况下磁盘上的数据页和缓存页是一 一对应起来的，都是16KB，一个数据页对应一个缓存页。

所以我们必须要知道Buffer Pool中哪些缓存页是空闲的状态。所以数据库会为Buffer Pool设计一个**free链表**，他是一个**双向链表**数据结构，这个free链表里，每个节点就是一个空闲的缓存页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中。

刚开始数据库启动的时候，可能所有的缓存页都是空闲的，因为此时可能是一个空的数据库，一条数据都没有，所以此时所有缓存页的描述数据块，都会被放入这个**free链表**中：

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104200709135.png" alt="image-20201104200709135" style="zoom: 50%;" />

大家可以看到上面出现了一个free链表，这个free链表里面就是各个缓存页的描述数据块，只要缓存页是空闲的，那么他们对应的描述数据块就会加入到这个free链表中，每个节点都会双向链接自己的前后节点，组成一个双向链表。

除此之外，这个free链表有一个基础节点，他会引用链表的头节点和尾节点，里面还存储了链表中有多少个描述数据块的节点，也就是有多少个空闲的缓存页。

#### 3  free链表占用多少内存空间？

可能有的人会以为这个描述数据块，在Buffer Pool里有一份，在free链表里也有一份，好像在内存里有两个一模一样的描述数据块，是么？

其实这么想就大错特错了。

这里要给大家讲明白一点，这个**free链表，他本身其实就是由Buffer Pool里的描述数据块组成的**，你可以认为是每个描述数据块里都有两个指针，一个是free_pre，一个是free_next，分别指向自己的上一个free链表的节点，以及下一个free链表的节点。

通过Buffer Pool中的描述数据块的free_pre和free_next两个指针，就可以把所有的描述数据块串成一个free链表，大家可以自己去思考一下这个问题。上面为了画图需要，所以把描述数据块单独画了一份出来，表示他们之间的指针引用关系。

**对于free链表而言，只有一个基础节点是不属于Buffer Pool的，他是40字节大小的一个节点，里面就存放了free链表的头节点的地址，尾节点的地址，还有free链表里当前有多少个节点。**

#### 4  如何将磁盘上的页读取到Buffer Pool的缓存页中去？

好了，现在我们可以来解答这一篇文章的最后一个问题了，当你需要把磁盘上的数据页读取到Buffer Pool中的缓存页里去的时候，是怎么做到的？

其实有了free链表之后，这个问题就很简单了。

首先，我们需要从free链表里获取一个描述数据块，然后就可以对应的获取到这个描述数据块对应的空闲缓存页，我们看下图所示。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104201400996.png" alt="image-20201104201400996" style="zoom:50%;" />

接着我们就可以把磁盘上的数据页读取到对应的缓存页里去，同时把相关的一些描述数据写入缓存页的描述数据块里去，比如这个数据页所属的表空间之类的信息，最后把那个描述数据块从free链表里去除就可以了，如下图所示。

 <img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104201553020.png" alt="image-20201104201553020" style="zoom: 33%;" />

这个描述数据块是怎么从free链表里移除的呢？用一段伪代码演示一下。

假设有一个描述数据块02，他的上一个节点是描述数据块01，下一个节点是描述数据块03，那么他在内存中的数据结构如下

````java
// 描述数据块
DescriptionDataBlock {
	// 这个块自己是block02
	block_id = block02;
	// 在free链表中的上一个节点的block01
	free_pre = block01;
	// 在free链表中的下一个节点的block03
	free_next = block03;
}
````

现在假设block03被使用了，要从free链表中移除，那么此时直接就可以把block02节点的free_next设置为null就可以了，block03就从free链表里失去引用关系了，如下所示。

````java
// 描述数据块
DescriptionDataBlock {
	// 这个块自己是block02
	block_id = block02;
	// 在free链表中的上一个节点的block01
	free_pre = block01;
	// 在free链表中的下一个节点是空的
	free_next = null;
}
````

#### 5  怎么知道数据页有没有被缓存？

接着我们来看下一个问题：你怎么知道一个数据页有没有被缓存呢？

我们在执行增删改查的时候，肯定是先看看这个数据页有没有被缓存，如果没被缓存就走上面的逻辑，从free链表中找到一个空闲的缓存页，从磁盘上读取数据页写入缓存页，写入描述数据，从free链表中移除这个描述数据块。

但是如果数据页已经被缓存了，那么就会直接使用了。

所以其实**数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。**

当你要使用一个数据页的时候，通过“表空间号+数据页号”作为key去这个哈希表里查一下，如果没有就读取数据页，如果已经有了，就说明数据页已经被缓存了。

我们看下图，又引入了一个数据页缓存哈希表的结构。也就是说，每次你读取一个数据页到缓存之后，都会在这个哈希表中写入一个key-value对，key就是表空间号+数据页号，value就是缓存页的地址，那么下次如果你再使用这个数据页，就可以从哈希表里直接读取出来他已经被放入一个缓存页了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104202338584.png" alt="image-20201104202338584" style="zoom:50%;" />

### 四  Buffer Pool数据处理流程 - flush链表

#### 1  脏数据页到底为什么会脏？

看一个很关键的问题，你在执行增删改的时候，如果发现数据页没缓存，那么必然会基于free链表找到一个空闲的缓存页，然后读取到缓存页里去，但是如果已经缓存了，那么下一次就必然会直接使用缓存页。

反正不管怎么样，你要更新的数据页都会在Buffer Pool的缓存页里，供你在内存中直接执行增删改的操作。

接着你肯定会去更新Buffer Pool的缓存页中的数据，此时一旦你更新了缓存页中的数据，那么缓存页里的数据和磁盘上的数据页里的数据，是不是就不一致了？这个时候，我们就说缓存页是脏数据，脏页。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104202904852.png" alt="image-20201104202904852" style="zoom: 33%;" />

#### 2  哪些缓存页是脏页呢？

最终这些在内存里更新的脏页的数据，都是要被刷新回磁盘文件的。但是这里就有一个问题了，不可能所有的缓存页都刷回磁盘的，因为有的缓存页可能是因为查询的时候被读取到Buffer Pool里去的，可能根本没修改过！

所以数据库在这里引入了另外一个跟free链表类似的**flush链表**，这个flush链表本质也是通过缓存页的描述数据块中的两个指针，让被修改过的缓存页的描述数据块，组成一个双向链表。

凡是被修改过的缓存页，都会把他的描述数据块加入到flush链表中去，flush的意思就是这些都是脏页，后续都是要flush刷新到磁盘上去的，所以flush链表的结构如下图所示，跟free链表几乎是一样的。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104203248652.png" alt="image-20201104203248652" style="zoom: 50%;" />

#### 3  flush链表构造的伪代码演示

我们用一些伪代码来给大家展示一下这个flush链表的构造过程，比如现在缓存页01被修改了数据，那么他就是脏页了，此时就必须把他加入到flush链表中去此时缓存页01的描述数据块假设如下所示

````java
// 描述数据块
DescriptionDataBlock {
	// 这个是缓存页01的数据块
	block_id = block01;
	// 在free链表中的上一个节点和下一个节点
	// 因为这个缓存页已经被更新过了，因此肯定不在free链表里了
	// 所以他在free链表中的两个指针都是null
	free_pre = null;
	free_next = null;
	// 在flush链表中的上一个节点和下一个节点
	// 因为flush链表中现在就他一个节点，所以两个指针都是null
	flush_pre = null;
	flush_next = null;
}
// flush链表的基础节点
FlushLinkListBaseNode{
	// 基础节点指向链表起始节点和结束节点的指针
	// flush链表中目前就一个缓存页01，所以指向他的描述数据块
	start = block01;
	end = block01;
	// flush链表中有几个节点
	count = 1;
}
````

现在flush链表的基础节点就指向了一个block01的节点，接着比如缓存页02被更新了，他也是脏页了，此时他的描述数据块也要被加入到flush链表中去，此时伪代码如下：

````java
// 描述数据块
DescriptionDataBlock {
	// 这个是缓存页01的数据块
	block_id = block01;
	// 在free链表中的上一个节点和下一个节点
	// 因为这个缓存页已经被更新过了，因此肯定不在free链表里了
	// 所以他在free链表中的两个指针都是null
	free_pre = null;
	free_next = null;
	// 在flush链表中的上一个节点和下一个节点
	// 因为flush链表中是起始节点，因此pre指针都是null
	flush_pre = null;
	// flush链表中他的下一个节点是block02，所以next指针指向block02
	flush_next = block02;
}
// 描述数据块
DescriptionDataBlock {
	// 这个是缓存页02的数据块
	block_id = block02;
	// 在free链表中的上一个节点和下一个节点
	// 因为这个缓存页已经被更新过了，因此肯定不在free链表里了
	// 所以他在free链表中的两个指针都是null
	free_pre = null;
	free_next = null;
	// 在flush链表中的上一个节点和下一个节点
	// 因为flush链表中他的上一个节点是block01
	flush_pre = block01;
	flush_next = null;
}
// flush链表的基础节点
FlushLinkListBaseNode{
	// 基础节点指向链表起始节点和结束节点的指针
	// flush链表中目前有缓存页01和02，所以指向他们的描述数据块
	start = block01;// 起始节点是01
	end = block02;// 结束节点是02
	// flush链表中有几个节点
	count = 2;
}
````

可以看到，当你更新缓存页的时候，通过变换缓存页中的描述数据块的flush链表的指针，就可以把脏页的描述数据块组成一个双向链表，也就是flush链表，而且flush链表的基础节点会指向起始节点和尾巴节点。通过这个flush链表，就可以记录下来哪些缓存页是脏页了

### 五  当Buffer Pool中的缓存页不够的时候，如何基于LRU算法淘汰部分缓存？

#### 1  为什么引入LRU链表

**1、如果Buffer Pool中的缓存页不够了怎么办？**

在加载数据到缓存页的时候，必然是要加载到空闲的缓存页里去的，所以必须要从free链表中找一个空闲的缓存页，然后把磁盘上的数据页加载到那个空闲的缓存页里去，我们看下图的红色箭头的示意。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105132602643.png" alt="image-20201105132602643" style="zoom: 40%;" />

随着你不停的把磁盘上的数据页加载到空闲的缓存页里去，free链表中的空闲缓存页会越来越少，所以，当你不停的把磁盘上的数据页加载到空闲缓存页里去时，最终会导致没有空闲页可用。

这个时候就必须把一个缓存页里被修改过的数据，给他刷到磁盘上的数据页里去，然后这个缓存页就可以清空了，让他重新变成一个空闲的缓存页。接着你再把磁盘上你需要的新的数据页加载到这个腾出来的空闲缓存页中去。

**2、引入LRU链表来判断哪些缓存页是不常用的**

接着我们就要解决下一个问题了，就是你怎么知道哪些缓存页经常被访问，哪些缓存页很少被访问？

此时就要引入一个新的LRU链表了，这个所谓的LRU就是Least Recently Used，最近最少使用的意思。通过这个LRU链表，我们可以知道哪些缓存页是最近最少被使用的，那么当你缓存页需要腾出来一个刷入磁盘的时候，不就可以选择那个LRU链表中最近最少被使用的缓存页了么？

这个LRU链表大致是怎么个工作原理呢？

这个时候，当你还要加载数据页到一个空闲缓存页的时候，怎么办呢？如下图。

简单来说，假设我们从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链表头部去，那么只要有数据的缓存页，他都会在LRU里了，而且最近被加载数据的缓存页，都会放到LRU链表的头部去。

另外假设某个缓存页的描述数据块本来在LRU链表的尾部，后续你只要查询或者修改了这个缓存页的数据，也要把这个缓存页挪动到LRU链表的头部去，也就是说最近被访问过的缓存页，一定在LRU链表的头部。

那么这样的话，当你的缓存页没有一个空闲的时候，你是不是要找出来那个最近最少被访问的缓存页去刷入磁盘？此时你就直接在LRU链表的尾部找到一个缓存页，他一定是最近最少被访问的那个缓存页！

然后你就把LRU链表尾部的那个缓存页刷入磁盘中，然后把你需要的磁盘数据页加载到腾出来的空闲缓存页中就可以了！

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105133545977.png" alt="image-20201105133545977" style="zoom:50%;" />

#### 2  简单LRU链表存在的问题

**MySQL预读机制导致的问题**

MySQL是存在**预读机制**的，这个所谓预读机制，说的就是当你从磁盘上加载一个数据页的时候，他可能会连带着把这个数据页相邻的其他数据页，也加载到缓存里去！

举个例子，假设现在有两个空闲缓存页，然后在加载一个数据页的时候，连带着把他的一个相邻的数据页也加载到缓存里去了，正好每个数据页放入一个空闲缓存页！

但是接下来呢，实际上只有一个缓存页是被访问了，另外一个通过预读机制加载的缓存页，其实并没有人访问，此时这两个缓存页可都在LRU链表的前面，如下图。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105172435348.png" alt="image-20201105172435348" style="zoom: 33%;" />

我们可以看到，前两个缓存页都是刚加载进来的，但是此时第二个缓存页是通过预读机制捎带着加载进来的，他也放到了链表的前面，但是他实际没人访问他。

除了第二个缓存页之外，第一个缓存页，以及尾巴上两个缓存页，都是一直有人访问的那种缓存页，只不过上图代表的是刚刚把头部两个缓存页加载进来的时候的一个LRU链表当时的情况。

这个时候，假如没有空闲缓存页了，这个时候，如果你把上图中LRU尾部的那个缓存页刷入磁盘然后清空其实是不合理的，因为他是之前一直频繁被人访问的！而通过预读机制加载进来的第二个缓存页，有可能是永远不会访问的。

**另外一种可能导致频繁被访问的缓存页被淘汰的场景**

另外一种可能导致频繁被访问的缓存页被淘汰的场景，那就是**全表扫描**。这个所谓的全表扫描，意思就是类似如下的SQL语句：

````sql
SELECT * FROM USERS
````

此时他没加任何一个where条件，会导致他直接一下子把这个表里所有的数据页，都从磁盘加载到Buffer Pool里去。这个时候他可能会一下子就把这个表的所有数据页都一一装入各个缓存页里去！此时可能LRU链表中排在前面的一大串缓存页，都是全表扫描加载进来的缓存页！那么如果这次全表扫描过后，后续几乎没用到这个表里的数据呢？

此时LRU链表的尾部，可能全部都是之前一直被频繁访问的那些缓存页！然后当你要淘汰掉一些缓存页腾出空间的时候，就会把LRU链表尾部一直被频繁访问的缓存页给淘汰掉了，而留下了之前全表扫描加载进来的大量的不经常访问的缓存页！

#### 3  基于冷热数据分离的思想设计LRU链表

为了解决简单的LRU链表的问题，真正MySQL在设计LRU链表的时候，采取的实际上是冷热数据分离的思想。

真正的LRU链表，会被拆分为两个部分，一部分是热数据，一部分是冷数据，这个冷热数据的比例是由**innodb_old_blocks_pct**参数控制的，他默认是**37**，也就是说冷数据占比37%。这个时候，LRU链表实际上看起来是下面这样子的。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105192420527.png" alt="image-20201105192420527" style="zoom: 33%;" />

**数据页第一次被加载到缓存的时候**

首先数据页第一次被加载到缓存的时候，缓存页会被放在冷数据区域的链表头部。

**冷数据区域的缓存页什么时候会被放入到热数据区域？**

接着我们来思考一个问题，第一次被加载了数据的缓存页，都会不停的移动到冷数据区域的链表头部，冷数据区域的缓存页肯定是会被使用的，那么冷数据区域的缓存页什么时候会放到热数据区域呢？

首先一种情况是，只要对冷数据区域的缓存页进行了一次访问，就立马把这个缓存页放到热数据区域的头部行不行呢？

其实这也是不合理的，如果你刚加载了一个数据页到那个缓存页，他是在冷数据区域的链表头部，然后立马（在1ms以内）就访问了一下这个缓存页，之后就再也不访问他了呢？难道这种情况你也要把那个缓存页放到热数据区域的头部吗？

所以MySQL设定了一个规则，他设计了一个**innodb_old_blocks_time**参数，默认值**1000**，也就是**1000毫秒**

也就是说，必须是一个数据页被加载到缓存页之后，在1s之后，你访问这个缓存页，他才会被挪动到热数据区域的链表头部去。

因为假设你加载了一个数据页到缓存去，然后过了1s之后你还访问了这个缓存页，说明你后续很可能会经常要访问它，这个时间限制就是1s，因此只有1s后你访问了这个缓存页，他才会给你把缓存页放到热数据区域的链表头部去。

所以我们看下面的图，文字说明做了一点改动，是数据加载到缓存页之后过了1s，你再访问这个缓存页，他就会被放入热数据区域的链表头部，如果是你数据刚加载到缓存页，在1s内你就访问缓存页，此时他是不会把这个缓存页放入热数据区域的头部的。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105194239181.png" alt="image-20201105194239181" style="zoom: 50%;" />

#### 4  LRU链表的热数据区域是如何进行优化的？

接着我们来看看LRU链表的热数据区域的一个性能优化的点，就是说，在热数据区域中，如果你访问了一个缓存页，是不是应该要把他立马移动到热数据区域的链表头部去？

我们看下面的图示。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105200238943.png" alt="image-20201105200238943" style="zoom: 50%;" />

其实热数据区域里的缓存页可能是经常被访问的，所以这么频繁的进行移动是不是性能也并不是很好，而且也没这个必要。

所以说，LRU链表的热数据区域的访问规则被优化了一下，即你只有在热数据区域的后3/4部分的缓存页被访问了，才会给你移动到链表头部去。**如果你是热数据区域的前面1/4的缓存页被访问，他是不会移动到链表头部去的。**

举个例子，假设热数据区域的链表里有100个缓存页，那么排在前面的25个缓存页，他即使被访问了，也不会移动到链表头部去的。但是对于排在后面的75个缓存页，他只要被访问，就会移动到链表头部去。

这样的话，他就可以尽可能的减少链表中的节点移动了。

### 六  总结

Buffer Pool在运行中被使用的时候，实际上会频繁的从磁盘上加载数据页到他的缓存页里去，然后free链表、flush链表、lru链表都会在使用的时候同时被使用。

比如数据加载到一个缓存页，free链表里会移除这个缓存页，然后lru链表的冷数据区域的头部会放入这个缓存页。然后如果你要是修改了一个缓存页，那么flush链表中会记录这个脏页，lru链表中还可能会把你从冷数据区域移动到热数据区域的头部去。

如果你是查询了一个缓存页，那么此时就会把这个缓存页在lru链表中从冷数据区域移动到热数据区域去，或者在热数据区域中也有可能会移动到头部去。

总之，MySQL在执行CRUD的时候，首先就是大量的操作缓存页以及对应的几个链表。然后在缓存页都满的时候，必然要想办法把一些缓存页给刷入磁盘，然后清空这几个缓存页，接着把需要的数据页加载到缓存页里去！

### 七  对于LRU链表中尾部的缓存页，是如何淘汰他们刷入磁盘的？

#### 1  定时把LRU尾部的部分缓存页刷入磁盘

首先第一个时机，并不是在缓存页满的时候，才会挑选LRU冷数据区域尾部的几个缓存页刷入磁盘，而是有一个后台线程，他会运行一个定时任务，这个定时任务每隔一段时间就会把LRU链表的冷数据区域的尾部的一些缓存页，刷入磁盘里去，清空这几个缓存页，把他们加入回free链表去！

所以实际上在缓存页没用完的时候，可能就会清空一些缓存页了，我们看下面的图示。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201105200850696.png" alt="image-20201105200850696" style="zoom: 40%;" />

所以如果在一个动态的运行效果中思考，大概就是你不停的加载数据到一些空闲的缓存页里去，然后这些缓存页可能被使用，会在lru链表中各种移动。然后同时有一个后台线程还不停的把冷数据区域的一些不用的缓存页刷入磁盘中，清空一些缓存页出来。

只要有缓存页被刷人磁盘，大家可以想象一下，那么这个缓存页必然会加入到free链表中，从flush链表中移除，从lru链表中移除。

#### 2  把flush链表中的一些缓存页定时刷入磁盘

如果仅仅是把LRU链表中的冷数据区域的缓存页刷入磁盘，大家觉得够吗？

明显不够啊，因为在lru链表的热数据区域里的很多缓存页可能也会被频繁的修改，难道他们永远都不刷入磁盘中了吗？

所以这个后台线程同时也会在MySQL不怎么繁忙的时候，找个时间把flush链表中的缓存页都刷入磁盘中，这样被你修改过的数据，迟早都会刷入磁盘的！

只要flush链表中的一波缓存页被刷入了磁盘，那么这些缓存页也会从flush链表和lru链表中移除，然后加入到free链表中去！

所以你可以理解为，你一边不停的加载数据到缓存页里去，不停的查询和修改缓存数据，然后free链表中的缓存页不停的在减少，flush链表中的缓存页不停的在增加，lru链表中的缓存页不停的在增加和移动。

另外一边，你的后台线程不停的在把lru链表的冷数据区域的缓存页以及flush链表的缓存页，刷入磁盘中来清空缓存页，然后flush链表和lru链表中的缓存页在减少，free链表中的缓存页在增加。

这就是一个动态运行起来的效果

#### 3  实在没有空闲缓存页了怎么办？

此时可能所有的free链表都被使用了，然后flush链表中有一大堆被修改过的缓存页，lru链表中有一大堆的缓存页，根据冷热数据进行了分离，大致是如此的效果。

这个时候如果要从磁盘加载数据页到一个空闲缓存页中，此时就会从LRU链表的冷数据区域的尾部找到一个缓存页，他一定是最不经常使用的缓存页！然后把他刷入磁盘和清空，然后把数据页加载到这个腾出来的空闲缓存页里去！

这就是MySQL的Buffer Pool缓存机制的一整套运行原理！我们已经完整的讲完了缓存页的加载和使用，以及free链表、flush链表、lru链表是怎么使用的，包括缓存页是如何刷入磁盘腾出来空闲缓存页的，以及缓存页没有空闲的时候应该怎么处理。