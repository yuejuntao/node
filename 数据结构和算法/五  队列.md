[TOC]



#### 一  如何理解**“**队列**”**？

队列这个概念⾮常好理解。你可以把它想象成排队买票，先来的先买，后来的⼈只能站末尾，不允许插队。先进者先出，这就是典型的 **队列**。 

我们知道，栈只⽀持两个基本操作：⼊栈**push()**和出栈**pop()**。队列跟栈⾮常相似，⽀持的操作也很有限，最基本的操作也是两个：

- ⼊队**enqueue()**，放⼀个数据到队列尾部；
- 出队**dequeue()**，从队列头部取⼀个元素。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201126111202533.png" alt="image-20201126111202533" style="zoom: 33%;" />

所以，队列跟栈⼀样，也是⼀种操作受限的线性表数据结构。 

作为⼀种⾮常基础的数据结构，队列的应⽤也⾮常⼴泛，特别是⼀些具有某些额外特性的队列，⽐如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作 ⽤。⽐如⾼性能队列Disruptor、Linux环形缓存，都⽤到了循环并发队列；Java concurrent并发包利⽤ArrayBlockingQueue来 实现公平锁等。 

#### 二  顺序队列和链式队列 

我们知道了，队列跟栈⼀样，也是⼀种抽象的数据结构。它具有先进先出的特性，⽀持在队尾插⼊元素，在队头删除元素，那 究竟该如何实现⼀个队列呢？ 

跟栈⼀样，队列可以⽤数组来实现，也可以⽤链表来实现。⽤数组实现的栈叫作顺序栈，⽤链表实现的栈叫作链式栈。同样， ⽤数组实现的队列叫作**顺序队列**，⽤链表实现的队列叫作**链式队列**。 

我们先来看下基于数组的实现⽅法。我⽤Java语⾔实现了⼀下，不过并不包含Java语⾔的⾼级语法，⽽且我做了⽐较详细的 注释，你应该可以看懂。

````java
// ⽤数组实现的队列
public class ArrayQueue {
    // 数组：items，数组⼤⼩：n
    private String[] items;
    private int n;
    // head表示队头下标，tail表示队尾下标
    private int head = 0;
    private int tail = 0;

    // 申请⼀个⼤⼩为capacity的数组
    public ArrayQueue(int capacity) {
        items = new String[capacity];
        n = capacity;
    }

    // ⼊队
    public boolean enqueue(String item) {
        // 如果tail == n 表示队列已经满了
        if (tail == n) {
            return false;
        }
        items[tail] = item;
        ++tail;
        return true;
    }

    // 出队
    public String dequeue() {
        // 如果head == tail 表示队列为空
        if (head == tail) {
            return null;
        }
        // 为了让其他语⾔的同学看的更加明确，把--操作放到单独⼀⾏来写了
        String ret = items[head];
        ++head;
        return ret;
    }
}
````

你可以结合下⾯这幅图来理解。当a、b、c、d依次⼊队之后，队列中的head指针指向下标为0的位置，tail指针指向下标为4的 

位置。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201126202407775.png" alt="image-20201126202407775" style="zoom:33%;" />

当我们调⽤两次出队操作之后，队列中head指针指向下标为2的位置，tail指针仍然指向下标为4的位置。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201126202440755.png" alt="image-20201126202440755" style="zoom:33%;" />

随着不停地进⾏⼊队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空 闲空间，也⽆法继续往队列中添加数据了。这个问题该如何解决呢？ 

你是否还记得，在数组那⼀节，我们也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。你还记得我们当 时是怎么解决的吗？对，⽤**数据搬移**！但是，每次进⾏出队操作都相当于删除数组下标为0的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。能不能优化⼀下呢？ 

实际上，我们在出队时可以不⽤搬移数据。如果没有空闲空间了，我们只需要在⼊队时，再集中触发⼀次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，我们稍加改造⼀下⼊队函数enqueue()的实现，就可以轻松解决刚才的问题了。 

下⾯是具体的代码：

````java
	// ⼊队操作，将item放⼊队尾
    public boolean enqueue(String item) {
        // tail == n表示队列末尾没有空间了
        if (tail == n) {
            // tail ==n && head==0，表示整个队列都占满了
            if (head == 0) return false;
            // 数据搬移
            for (int i = head; i < tail; ++i) {
                items[i - head] = items[i];
            }
            // 搬移完之后重新更新head和tail
            tail -= head;
            head = 0;
        }
        items[tail] = item;
        ++tail;
        return true;
    }
````

从代码中我们看到，当队列的tail指针移动到数组的最右边后，如果有新的数据⼊队，我们可以将head到tail之间的数据，整体 搬移到数组中0到tail-head的位置。 

<img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201126203402087.png" alt="image-20201126203402087" style="zoom:33%;" />

接下来，我们再来看下基于链表的队列实现⽅法。 

基于链表的实现，我们同样需要两个指针：head指针和tail指针。它们分别指向链表的第⼀个结点和最后⼀个结点。如图所示，⼊队时，tail->next= new_node, tail = tail->next；出队时，head = head->next。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127103717354.png" alt="image-20201127103717354" style="zoom:33%;" />

````java
/**
 * 基于链表实现的队列
 */
public class QueueBasedOnLinkedList {

  // 队列的队首和队尾
  private Node head = null;
  private Node tail = null;

  // 入队
  public void enqueue(String value) {
    if (tail == null) {
      Node newNode = new Node(value, null);
      head = newNode;
      tail = newNode;
    } else {
      tail.next = new Node(value, null);
      tail = tail.next;
    }
  }

  // 出队
  public String dequeue() {
    if (head == null) return null;
    String value = head.data;
    head = head.next;
    if (head == null) {
      tail = null;
    }
    return value;
  }

  public void printAll() {
    Node p = head;
    while (p != null) {
      System.out.print(p.data + " ");
      p = p.next;
    }
    System.out.println();
  }

  private static class Node {
    private String data;
    private Node next;
    public Node(String data, Node next) {
      this.data = data;
      this.next = next;
    }

    public String getData() {
      return data;
    }
  }
}
````

####  三  循环队列

我们刚才⽤数组来实现队列的时候，在tail==n时，会有数据搬移操作，这样⼊队操作性能就会受到影响。那有没有办法能够避 免数据搬移呢？我们来看看循环队列的解决思路。 

循环队列，顾名思义，它⻓得像⼀个环。原本数组是有头有尾的，是⼀条直线。现在我们把⾸尾相连，扳成了⼀个环。我画了⼀张图，你可以直观地感受⼀下。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127111002797.png" alt="image-20201127111002797" style="zoom:33%;" />

我们可以看到，图中这个队列的⼤⼩为8，当前head=4，tail=7。当有⼀个新的元素a⼊队时，我们放⼊下标为7的位置。但这个时候，我们并不把tail更新为8，⽽是将其在环中后移⼀位，到下标为0的位置。当再有⼀个元素b⼊队时，我们将b放⼊下标为0的位置，然后tail加1更新为1。所以，在a，b依次⼊队之后，循环队列中的元素就变成了下⾯的样⼦： 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127111217796.png" alt="image-20201127111217796" style="zoom:33%;" />

通过这样的⽅法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要⽐前⾯讲的⾮循环队列难多了。要想写出没有bug的循环队列的实现代码，我个⼈觉得，最关键的是，确定好**队空和队满**的判定条件。 

在⽤数组实现的⾮循环队列中，队满的判断条件是tail == n，队空的判断条件是head == tail。那针对循环队列，如何判断队空和队满呢？ 

队列为空的判断条件仍然是head == tail。但队列满的判断条件就稍微有点复杂了。我画了⼀张队列满的图，你可以看⼀下， 试着总结⼀下规律。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127111336882.png" alt="image-20201127111336882" style="zoom:33%;" />

就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结⼀下规律就是：(3+1)%8=4。多画⼏张队满的图，你就会发 现，当队满时:

````
(tail + 1) % n = head
````

你有没有发现，当队列满时，图中的tail指向的位置实际上是没有存储数据的。所以，**循环队列会浪费⼀个数组的存储空间**。 

Talk is cheap，如果还是没怎么理解，那就show you code吧

````java
/**
 * 循环队列
 */
public class CircularQueue {
	// 数组：items，数组大小：n
	private String[] items;
    // 队列大小
	private int n = 0;
	// head表示队头下标，tail表示队尾下标
	private int head = 0;
	private int tail = 0;

	// 申请一个大小为capacity的数组,这里加1是因为tail会占用一个位无法存储数据
	public CircularQueue(int capacity) {
		items = new String[capacity + 1];
		n = capacity + 1;
	}

	// 入队，入队都是在尾部插入
	public boolean enqueue(String item) {
		// 队列满了
		if ((tail + 1) % n == head) {
			return false;    
		}
		items[tail] = item;
		// tail往前移一位，通过 (tail + 1) % n 保证是循环后移，且不会发生越界
		tail = (tail + 1) % n;
		return true;
	}

	// 出队，出队都是在头部删除
	public String dequeue() {
		// 如果head == tail 表示队列为空
		if (head == tail) {
			return null;
		} 
		String ret = items[head];
		head = (head + 1) % n;
		return ret;
	}
    
    /**
     * Get the front item from the queue. 获取头部元素
     */
    public int Front() {
        if (head == tail) {
            return -1;
        }
        // 防止数组越界
        return nums[head % n];
    }

    /**
     * Get the last item from the queue. 获取尾部元素
     */
    public int Rear() {
        if (head == tail) {
            return -1;
        }
        // 使用(tail + n - 1) % n 获取tail的前一个元素，防止数组越界
        return nums[(tail + n - 1) % n];
    }

    /**
     * Checks whether the circular queue is empty or not.
     */
    public boolean isEmpty() {
        return head == tail;
    }

    /**
     * Checks whether the circular queue is full or not.
     */
    public boolean isFull() {
        return (tail + 1) % n == head;
    }

	public void printAll() {
		if (0 == n) {
			return;
		}
		for (int i = head; i % n != tail; i = (i + 1) % n) {
			System.out.print(items[i] + " ");
		}
		System.out.println();
	}
}
````

#### 四  设计双端循环队列

````java
class MyCircularDeque {

    // 定义一个数组用来保存队列元素
    int[] nums;
    // 头指针，每次弹出数据都从head取
    int head = 0;
    // 尾指针，每次压入数据都从tail压入
    int tail = 0;
    // 数组中元素数量
    int capacity = 0;

    /**
     * Initialize your data structure here. Set the size of the deque to be k.
     */
    public MyCircularDeque(int k) {
        nums = new int[k + 1];
        capacity = k + 1;
    }

    /**
     * Adds an item at the front of Deque. Return true if the operation is successful.
     */
    public boolean insertFront(int value) {
        if ((tail + 1) % capacity == head) {
            return false;
        }
        // 因为是在头部插入的，因此head需要向前移一位
        nums[(head + capacity - 1) % capacity] = value;
        head = (head + capacity - 1) % capacity;
        return true;
    }

    /**
     * Adds an item at the rear of Deque. Return true if the operation is successful.
     */
    public boolean insertLast(int value) {
        if ((tail + 1) % capacity == head) {
            return false;
        }
        // 因为是在尾部插入的，因此tail需要后移一位
        nums[tail % capacity] = value;
        tail = (tail + 1) % capacity;
        return true;
    }

    /**
     * Deletes an item from the front of Deque. Return true if the operation is successful.
     */
    public boolean deleteFront() {

        if (head == tail) {
            return false;
        }
        head = (head + 1) % capacity;
        return true;
    }

    /**
     * Deletes an item from the rear of Deque. Return true if the operation is successful.
     */
    public boolean deleteLast() {

        if (head == tail) {
            return false;
        }
        tail = (tail + capacity - 1) % capacity;
        return true;
    }

    /**
     * Get the front item from the deque.
     */
    public int getFront() {
        if (head == tail) {
            return -1;
        }
        return nums[head % capacity];
    }

    /**
     * Get the last item from the deque.
     */
    public int getRear() {
        if (head == tail) {
            return -1;
        }
        return nums[(tail + capacity - 1) % capacity];
    }

    /**
     * Checks whether the circular deque is empty or not.
     */
    public boolean isEmpty() {
        return head == tail;
    }

    /**
     * Checks whether the circular queue is full or not.
     */
    public boolean isFull() {
        return (tail + 1) % capacity == head;
    }
}

````

#### 四  阻塞队列和并发队列

前⾯讲的内容理论⽐较多，看起来很难跟实际的项⽬开发扯上关系。确实，队列这种数据结构很基础，平时的业务开发不⼤可 能从零实现⼀个队列，甚⾄都不会直接⽤到。⽽⼀些具有特殊特性的队列应⽤却⽐较⼴泛，⽐如阻塞队列和并发队列。 

阻塞队列其实就是在队列基础上增加了阻塞操作：

- 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；
- 如果队列已经满了，那么插⼊数据的操作就会被阻塞，直到队列中有空闲位置后再插⼊数据，然后再返回。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127141107822.png" alt="image-20201127141107822" style="zoom:33%;" />

你应该已经发现了，上述的定义就是⼀个“⽣产者-消费者模型”，我们可以使⽤阻塞队列，轻松实现⼀个“⽣产者-消费者模型”！ 

这种基于阻塞队列实现的“⽣产者-消费者模型”，可以有效地协调⽣产和消费的速度。当“⽣产者”⽣产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，⽣产者就阻塞等待，直到“消费者”消费了数据，“⽣产者”才会被唤醒继续“⽣产”。 

⽽且不仅如此，基于阻塞队列，我们还可以通过协调“⽣产者”和“消费者”的个数，来提⾼数据的处理效率。⽐如前⾯的例⼦，我们可以多配置⼏个“消费者”，来应对⼀个“⽣产者”。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201127141401728.png" alt="image-20201127141401728" style="zoom:33%;" />

前⾯我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现⼀个线程安全的队列呢？ 

线程安全的队列我们叫作并发队列。最简单直接的实现⽅式是直接在enqueue()、dequeue()⽅法上加锁，但是锁粒度⼤并发度会⽐较低，同⼀时刻仅允许⼀个存或者取操作。实际上，基于数组的循环队列，利⽤CAS原⼦操作，可以实现⾮常⾼效的并发队列。这也是循环队列⽐链式队列应⽤更加⼴泛的原因。在实战篇讲Disruptor的时候，我会再详细讲并发队列的应⽤。 

#### 五  队列应用

##### 1  线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略⼜是如何实现的呢？

我们⼀般有两种处理策略。第⼀种是⾮阻塞的处理⽅式，直接拒绝任务请求；另⼀种是阻塞的处理⽅式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？ 

我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前⾯说过，队列有基于链表和基于数组这两种实现⽅式。这两种实现⽅式对于排队请求⼜有什么区别呢？ 

基于链表的实现⽅式，可以实现⼀个⽀持⽆限排队的**⽆界队列（unbounded queue）**，但是可能会导致过多的请求排队等待，请求处理的响应时间过⻓。所以，针对响应时间⽐较敏感的系统，基于链表实现的⽆限排队的线程池是不合适的。 

⽽基于数组实现的**有界队列（bounded queue）**，队列的⼤⼩有限，所以线程池中排队的请求超过队列⼤⼩时，接下来的请求就会被拒绝，这种⽅式对响应时间敏感的系统来说，就相对更加合理。不过，设置⼀个合理的队列⼤⼩，也是⾮常有讲究的。 

队列太⼤导致等待的请求太多，队列太⼩会导致⽆法充分利⽤系统资源、发挥最⼤性能。 

除了前⾯讲到队列应⽤在线程池请求排队的场景之外，队列可以应⽤在任何有限资源池中，⽤于排队请求，⽐如数据库连接池等。实际上，对于⼤部分资源有限的场景，当没有空闲资源时，基本上都可以通过**“**队列**”**这种数据结构来实现请求排队。 