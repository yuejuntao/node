[TOC]

#### 一  提出问题：为什么插⼊排序⽐冒泡排序更受欢迎 

插⼊排序和冒泡排序的时间复杂度相同，都是**O(n²)**，在实际的软件开发⾥，为什么我们更倾向于使⽤插⼊排序算法⽽不是冒泡排序算法呢？

带着这个问题，我们开始今天的内容！ 

#### 二  怎么分析一个排序算法？

学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析⼀个排序算法。那分析⼀个排序算法，要从哪⼏个⽅⾯⼊⼿呢？ 

##### 1  排序算法的执⾏效率（时间复杂度）

对于排序算法执⾏效率的分析，我们⼀般会从这⼏个⽅⾯来衡量： 

###### （1）最好情况、最坏情况、平均情况时间复杂度

我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。 

为什么要区分这三种时间复杂度呢？第⼀，有些排序算法会区分，为了好对⽐，所以我们最好都做⼀下区分。第⼆，对于要排 序的数据，有的接近有序，有的完全⽆序。有序度不同的数据，对于排序的执⾏时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。 

###### （2）时间复杂度的系数、常数 、低阶

我们知道，时间复杂度反应的是数据规模n很⼤的时候的⼀个增⻓趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很⼩的数据，所以，在对同⼀阶时间复杂度的排序算法性能对⽐的时候，我们就要把系数、常数、低阶也考虑进来。

###### （3）⽐较次数和交换（或移动）次数

基于⽐较的排序算法的执⾏过程，会涉及两种操作，⼀种是**元素⽐较⼤⼩**，另⼀种是**元素交换或移动**。所以，如果我们在分析排序算法的执⾏效率的时候，应该把⽐较次数和交换（或移动）次数也考虑进去。

##### 2  排序算法的内存消耗（空间复杂度）

我们前⾯讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引⼊了⼀个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是O(1)的排序算法。

##### 3  排序算法的稳定性 

仅仅⽤执⾏效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有⼀个重要的度量指标，**稳定性**。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 

我通过⼀个例⼦来解释⼀下。⽐如我们有⼀组数据2，9，3，4，8，3，按照⼤⼩排序之后就是2，3，3，4，8，9。 

这组数据⾥有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发⽣变化，那对应的排序算法就叫作不稳定的排序算法。 

你可能要问了，两个3哪个在前，哪个在后有什么关系啊，稳不稳定⼜有什么关系呢？为什么要考察排序算法的稳定性呢？ 

很多数据结构和算法课程，在讲排序的时候，都是⽤整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，⽽是⼀组对象，我们需要按照对象的某个key来排序。 

⽐如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，⼀个是下单时间，另⼀个是订单⾦额。如果我们现在有10万条订单数据，我们希望按照⾦额从⼩到⼤对订单数据排序。对于⾦额相同的订单，我们希望按照下单时间从早到晚有序。对于这样⼀个排序需求，我们怎么来做呢？ 

最先想到的⽅法是：我们先按照⾦额对订单数据进⾏排序，然后，再遍历排序之后的订单数据，对于每个⾦额相同的⼩区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。 

借助稳定排序算法，这个问题可以⾮常简洁地解决。解决思路是这样的：

我们先按照下单时间给订单排序，注意是按照下单时间，不是⾦额。排序完成之后，我们⽤稳定排序算法，按照订单⾦额重新排序。两遍排序之后，我们得到的订单数据就是按照⾦额从⼩到⼤排序，⾦额相同的订单按照下单时间从早到晚排序的。为什么呢？ 

稳定排序算法可以保持⾦额相同的两个对象，在排序之后的前后顺序不变。第⼀次排序之后，所有的订单按照下单时间从早到晚有序了。在第⼆次排序中，我们⽤的是稳定的排序算法，所以经过第⼆次排序之后，相同⾦额的订单仍然保持下单时间从早到晚有序。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207114644517.png" alt="image-20201207114644517" style="zoom:33%;" />

#### 三  排序算法总结

##### 1  排序算法总结图

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207115700239.png" alt="image-20201207115700239" style="zoom: 33%;" />

**图片名词解释：**

- n: 数据规模
- k: “桶”的个数
- In-place: 占用常数内存，不占用额外内存
- Out-place: 占用额外内存

##### 2  比较和非比较的区别

常见的**快速排序、归并排序、堆排序、冒泡排序**等属于**比较排序**。**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。**

在**冒泡排序**之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在**归并排序、快速排序**之类的排序中，问题规模通过**分治法**消减为logN次，所以时间复杂度平均**O(nlogn)**。

比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，**比较排序适用于一切需要排序的情况。**

**计数排序、基数排序、桶排序**则属于**非比较排序**。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。

非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度**O(n)**。

**非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**

#### 四  冒泡排序（**Bubble Sort**）

##### 1  算法介绍

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进⾏⽐较，看是否满⾜⼤⼩关系要求。如果不满⾜就让它俩互换。⼀次冒泡会让⾄少⼀个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序⼯作。 

我⽤⼀个例⼦，带你看下冒泡排序的整个过程。我们要对⼀组数据4，5，6，3，2，1，从⼩到到⼤进⾏排序。第⼀次冒泡操作的详细过程就是这样：

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207120127087.png" alt="image-20201207120127087" style="zoom:33%;" />

可以看出，经过⼀次冒泡操作之后，6这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进⾏6次这样的冒泡操作就⾏了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207120419810.png" alt="image-20201207120419810" style="zoom:33%;" />

##### 2  算法实现

````java
	public int[] bubbleSort(int[] arr) {
        //需要遍历m次
        for (int m = 0; m < arr.length; m++) {
            //这里-m是因为后面的元素以排序完成，不需要再排序
            for (int n = 0; n < arr.length - 1 - m; n++) {
                //每个元素和他后面的元素做比较，如果当前元素大于后面的元素，则交换，使指针n一直指向当前最大的元素
                if (arr[n] > arr[n + 1]) {
                    int temp = arr[n];
                    arr[n] = arr[n + 1];
                    arr[n + 1] = temp;
                }
            }
        }
        return arr;
    }
````

实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不⽤再继续执⾏后续的冒泡操作。我这⾥还有另外⼀个例⼦，这⾥⾯给6个元素排序，只需要4次冒泡操作就可以了。

````java
	public int[] bubbleSort1(int[] arr) {
        //需要遍历m次
        for (int m = 0; m < arr.length; m++) {
            // 提前退出冒泡循环的标志位
            boolean flag = false;
            //这里-m是因为后面的元素以排序完成，不需要再排序
            for (int n = 0; n < arr.length - 1 - m; n++) {
                //每个元素和他后面的元素做比较，如果当前元素大于后面的元素，则交换，使指针n一直指向当前最大的元素
                if (arr[n] > arr[n + 1]) {
                    int temp = arr[n];
                    arr[n] = arr[n + 1];
                    arr[n + 1] = temp;
                    // 有数据交换，则置为true
                    flag = true;
                }
            }
            // 如果这次比较后没有数据交换，则退出
            if (!flag){
                return arr;
            }
        }
        return arr;
    }
````

##### 3  算法分析

第⼀，冒泡排序是原地排序算法吗？ 

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是⼀个原地排序算法。 

第⼆，冒泡排序是稳定的排序算法吗？ 

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素⼤⼩相等的 

时候，我们不做交换，相同⼤⼩的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 

第三，冒泡排序的时间复杂度是多少？ 

最好情况下，要排序的数据已经是有序的了，我们只需要进⾏⼀次冒泡操作，就可以结束了，所以最好情况时间复杂度是 

O(n)。⽽最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进⾏n次冒泡操作，所以最坏情况时间复杂度为O(n2)。

**最佳情况：T(n) = O(n)  最差情况：T(n) = O(n²)  平均情况：T(n) = O(n²)**

#### 五  插入排序（**Insertion Sort**） 

##### 1  算法介绍

我们先来看⼀个问题。⼀个有序的数组，我们往⾥⾯添加⼀个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插⼊的位置将其插⼊即可。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207133647526.png" alt="image-20201207133647526" style="zoom:33%;" />

这是⼀个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种⽅法保持集合中的数据⼀直有序。⽽对于⼀组静态数据，我们也可以借鉴上⾯讲的插⼊⽅法，来进⾏排序，于是就有了插⼊排序算法。 

那插⼊排序具体是如何借助上⾯的思想来实现排序的呢？ 

⾸先，我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有⼀个元素，就是数组的第⼀个元素。插⼊算法的核⼼思想是取未排序区间中的元素，在已排序区间中找到合适的插⼊位置将其插⼊，并保证已排序区间数据⼀直有序。重复这个过程，直到未排序区间中元素为空，算法结束。 

如图所示，要排序的数据是4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207133912161.png" alt="image-20201207133912161" style="zoom:33%;" />

插⼊排序也包含两种操作，⼀种是**元素的⽐较**，⼀种是**元素的移动**。当我们需要将⼀个数据a插⼊到已排序区间时，需要拿a与已排序区间的元素依次⽐较⼤⼩，找到合适的插⼊位置。找到插⼊点之后，我们还需要将插⼊点之后的元素顺序往后移动⼀位，这样才能腾出位置给元素a插⼊。 

对于不同的查找插⼊点⽅法（从头到尾、从尾到头），元素的⽐较次数是有区别的。但对于⼀个给定的初始序列，移动操作的次数总是固定的

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207141412353.png" alt="image-20201207141412353" style="zoom:33%;" />

##### 2  算法实现

````java
	/**
     * 使用for循环实现
     */
    public int[] insertionSortFor(int[] arr) {
        // 记录要插入的位置
        int insertIndex;
        // 记录当前要插入的元素
        int current;
        // 默认索引为0的元素已排序，因此后i=1开始遍历每一个元素
        for (int i = 1; i < arr.length; i++) {
            // 先指向当前要插入的元素的索引
            insertIndex = i;
            // 获取将要插入的元素
            current = arr[i];
            // 从后向前遍历已排序的元素，如果已排序的元素大于将要插入的元素，则将已排序的元素后移一位
            for (int j = i - 1; j >= 0; j--) {
                if (arr[j] > current) {
                    arr[j + 1] = arr[j];
                    // 如果后移，则要插入的位置减1
                    insertIndex--;
                } else {
                    // 如果小于等于，则不需要再遍历
                    break;
                }
            }
            // 将要插入的元素插入到当前位置
            arr[insertIndex] = current;
        }
        return arr;
    }
````

##### 3  算法分析

第⼀，插⼊排序是原地排序算法吗？ 

从实现过程可以很明显地看出，插⼊排序算法的运⾏并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是⼀个原地排序算法。 

第⼆，插⼊排序是稳定的排序算法吗？ 

在插⼊排序中，对于值相同的元素，我们可以选择将后⾯出现的元素，插⼊到前⾯出现元素的后⾯，这样就可以保持原有的前后顺序不变，所以插⼊排序是稳定的排序算法。 

第三，插⼊排序的时间复杂度是多少？ 

如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组⾥⾯查找插⼊位置，每次只需 要⽐较⼀个数据就能确定插⼊的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这⾥是从尾到头遍历已经有序的数据。

如果数组是倒序的，每次插⼊都相当于在数组的第⼀个位置插⼊新的数据，所以需要移动⼤量的数据，所以最坏情况时间复杂度为O(n²)。 

还记得我们在数组中插⼊⼀个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插⼊排序来说，每次插⼊操作都相当于在数组中插⼊⼀个数据，循环执⾏n次插⼊操作，所以平均时间复杂度为O(n²)。 

**最佳情况：T(n) = O(n)  最坏情况：T(n) = O(n²)  平均情况：T(n) = O(n²)**

#### 六  选择排序（**Selection Sort**）

##### 1  算法介绍

选择排序算法的实现思路有点类似插⼊排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最⼩的元素，将其放到已排序区间的末尾。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201207143320110.png" alt="image-20201207143320110" style="zoom:33%;" />

表现**最稳定的排序算法之一**，因为**无论什么数据进去都是O(n2)的时间复杂度**，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

##### 2  算法实现

````java
	public int[] selectionSort(int[] arr) {
        int minVal;//中间变量
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;//用来指向最小值的引用
            for (int j = i + 1; j < arr.length; j++) {//遍历之后的每一个元素，找到最小元素的引用
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;//保存最小数的索引
                }
            }
            minVal = arr[minIndex];//将最小的数和当前引用为i的元素交换
            arr[minIndex] = arr[i];
            arr[i] = minVal;
        }
        return arr;
    }
````

##### 3  算法分析

⾸先，选择排序空间复杂度为O(1)，是⼀种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n²)。你可以⾃⼰来分析看看。 

那选择排序是稳定的排序算法吗？这个问题我着重来说⼀下。 

答案是否定的，选择排序是⼀种不稳定的排序算法。从我前⾯画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最⼩值，并和前⾯的元素交换位置，这样破坏了稳定性。 

⽐如5，8，5，2，9这样⼀组数据，使⽤选择排序算法来排序的话，第⼀次找到最⼩元素2，与第⼀个5交换位置，那第⼀个5 和中间的5顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插⼊排序，选择排序就稍微逊⾊了。 

**最佳情况：T(n) = O(n²)  最差情况：T(n) = O(n²)  平均情况：T(n) = O(n²)**

#### 七  解答开篇

我们来看开篇的问题：冒泡排序和插⼊排序的时间复杂度都是O(n²)，都是原地排序算法，为什么插⼊排序要⽐冒泡排序更受欢迎呢？ 

从代码实现上来看，冒泡排序的数据交换要⽐插⼊排序的数据移动要复杂，冒泡排序需要3个赋值操作，⽽插⼊排序只需要1个。我们来看这段操作：冒泡排序中数据的交换操作： 

````java
if (a[j] > a[j+1]) { // 交换 
	int tmp = a[j]; 
	a[j] = a[j+1]; 
	a[j+1] = tmp; 
	flag = true; 
}

//插⼊排序中数据的移动操作： 
if (a[j] > value) { 
	a[j+1] = a[j]; // 数据移动 
} else { 
	break; 
} 
````

我们把执⾏⼀个赋值语句的时间粗略地计为单位时间（unit_time），然后分别⽤冒泡排序和插⼊排序对同⼀个逆序度是K的数组进⾏排序。⽤冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。⽽插⼊排序中数据移动操作只需要K个单位时间。 

这个只是我们⾮常理论的分析，为了实验，针对上⾯的冒泡排序和插⼊排序的Java代码，我写了⼀个性能对⽐测试程序，随机⽣成10000个数组，每个数组中包含200个数据，然后在我的机器上分别⽤冒泡和插⼊排序算法来排序，冒泡排序算法⼤约700ms才能执⾏完成，⽽插⼊排序只需要100ms左右就能搞定！ 

所以，虽然冒泡排序和插⼊排序在时间复杂度上是⼀样的，都是O(n2)，但是如果我们希望把性能优化做到极致，那肯定⾸选插⼊排序。插⼊排序的算法思路也有很⼤的优化空间，我们只是讲了最基础的⼀种。如果你对插⼊排序的优化感兴趣，可以⾃⾏学习⼀下希尔排序。 

#### 八  希尔排序

##### 1  算法介绍

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n²）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

**希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**

```html
https://www.cnblogs.com/chengxiao/p/6104371.html
```

#### 九  归并排序

##### 1  算法介绍

归并排序的核⼼思想还是蛮简单的。如果要排序⼀个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在⼀起，这样整个数组就都有序了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201224211017786.png" alt="image-20201224211017786" style="zoom:33%;" />

归并排序使⽤的就是**分治思想**。

分治，顾名思义，就是分⽽治之，将⼀个⼤问题分解成⼩的⼦问题来解决。⼩的⼦问题解决了，⼤问题也就解决了。 

从我刚才的描述，你有没有感觉到，分治思想跟我们前⾯讲的递归思想很像。是的，分治算法⼀般都是⽤递归来实现的。**分治是⼀种解决问题的处理思想，递归是⼀种编程技巧，这两者并不冲突**。

前⾯我通过举例让你对归并有了⼀个感性的认识，⼜告诉你，归并排序⽤的是分治思想，可以⽤递归来实现。我们现在就来看看如何⽤递归代码来实现归并排序。 

前面讲过，写递归代码的技巧就是，分析得出递推公式，然后找到终⽌条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。 

````java
递推公式： 
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 
终⽌条件：
p >= r 不⽤再继续分解
````

我来解释⼀下这个递推公式。 

merge_sort(p…r)表示，给下标从p到r之间的数组排序。我们将这个排序问题转化为了两个⼦问题，merge_sort(p…q)和merge_sort(q+1…r)，其中下标q等于p和r的中间位置，也就是(p+r)/2。当下标从p到q和从q+1到r这两个⼦数组都排好序之后，我们再将两个有序的⼦数组合并在⼀起，这样下标从p到r之间的数据就也排好序了。 

有了递推公式，转化成代码就简单多了。

##### 2  算法实现

````java
	public int[] mergeSort(int[] array, int left, int right) {
        // 递归终止条件
        if (left >= right) {
            return new int[]{array[left]};
        }
        // 获取中间位置
        int mid = (right + left) / 2;
        // 递归归并排序左边数组，返回左边排好序的数组
        int[] l = mergeSort(array, left, mid);
        // 递归归并排序右边数组，返回右边排好序的数组
        int[] r = mergeSort(array, mid + 1, right);
        // 将已经排好序的左边数组和右边数组合并
        return merge(l, r);
    }
````

````java
	public static int[] merge(int[] l, int[] r) {
        // 创建一个新的数组
        int[] result = new int[l.length + r.length];
        //新数组索引
        int p = 0;
        //左数组索引
        int lp = 0;
        //右数组索引
        int rp = 0;
        // 按大小顺序插入到新数组中
        while (lp < l.length && rp < r.length) {
            result[p++] = l[lp] < r[rp] ? l[lp++] : r[rp++];
        }
        // 把剩余的元素插入到新数组中
        while (lp < l.length) {
            result[p++] = l[lp++];
        }
        while (rp < r.length) {
            result[p++] = r[rp++];
        }
        return result;
    }
````

````java
	@Test
    public void mergeSortTest() {
        int[] beforeArr = {2, 3, 1, 8, 6, 7, 5};
        int[] afterArr = mergeSort(beforeArr, 0, beforeArr.length - 1);
        System.out.println("归并排序结果：");
        Arrays.stream(afterArr).forEach(System.out::print);
    }
````

##### 3  算法分析

时间复杂度：平均：O(nlogn)，最差：O(nlogn)，最好：O(nlogn)
空间复杂度：O(n)
是否稳定：稳定

#### 十  快速排序（Quicksort）

##### 1  算法介绍

快排利⽤的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不⼀样。我们待会会讲两者的区别。现在，我们先来看下快排的核⼼思想。 

快排的思想是这样的：如果要排序数组中下标从p到r之间的⼀组数据，我们选择p到r之间的任意⼀个数据作为pivot（分区点）。 

我们遍历p到r之间的数据，将⼩于pivot的放到左边，将⼤于pivot的放到右边，将pivot放到中间。经过这⼀步骤之后，数组p到r之间的数据就被分成了三个部分，前⾯p到q-1之间都是⼩于pivot的，中间是pivot，后⾯的q+1到r之间是⼤于pivot的。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201225205757145.png" alt="image-20201225205757145" style="zoom:33%;" />

根据分治、递归的处理思想，我们可以⽤递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩⼩为1，就说明所有的数据都有序了。 

如果我们⽤递推公式来将上⾯的过程写出来的话，就是这样： 

````java
递推公式： 
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r) 
终⽌条件： 
p >= r
````

##### 2  代码实现

````java
	public int[] quickSort(int[] arr, int left, int right) {
        // 边界条件判断
        if (left < right) {
            //分区，返回的partitionIndex左边都是小于基准值的数据，右边都是大于基准值的数据
            int partitionIndex = partition(arr, left, right);
            //递归对左边进行快排
            quickSort(arr, left, partitionIndex - 1);
            //递归对右边进行快排
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
    }
````

````java
	// 分区操作		
	public int partition(int[] arr, int left, int right) {    
        // 设定基准值（pivot）,默认是left值
        int pivot = left;
        // index指向比基准值大的数，i的值从index往后遍历，找到小于基准值的数据，和index进行交换
        int index = pivot + 1;
        // i往后遍历，寻找小于基准值的数据，和index处的元素交换，遍历完后，大于基准值的数在后面，小于的在前面
        for (int i = index; i <= right; i++) {
            // 如果小于基准值
            if (arr[i] < arr[pivot]) {
                // 交换
                swap(arr, i, index);
                // 大数索引加1
                index++;
            }
        }
        // 交换基准值和最后一个小于基准值的数
        swap(arr, pivot, index - 1);
        // 返回基准值的索引
        return index - 1;
    }

	// 交换数组的两个元素
    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
````

##### 3  快排和归并的区别

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201225221710031.png" alt="image-20201225221710031" style="zoom:33%;" />

可以发现，归并排序的处理过程是由下到上的，先处理⼦问题，然后再合并。⽽快排正好相反，它的处理过程是由上到下的，先分区，然后再处理⼦问题。归并排序虽然是稳定的、时间复杂度为O(nlogn)的排序算法，但是它是⾮原地排序算法。我们前⾯讲过，归并之所以是⾮原地排序算法，主要原因是合并函数⽆法在原地执⾏。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占⽤太多内存的问题

#### 十一  ：O(n)时间复杂度内求⽆序数组中的第K⼤元素

⽐如，4， 2， 5， 12， 3这样⼀组数据，第3⼤元素就是4。 

我们选择数组区间A[0…n-1]的最后⼀个元素A[n-1]作为pivot，对数组A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。 

如果p+1=K，那A[p]就是要求解的元素；如果K>p+1, 说明第K⼤元素出现在A[p+1…n-1]区间，我们再按照上⾯的思路递归地在A[p+1…n-1]这个区间内查找。同理，如果K<p+1，那我们就在A[0…p-1]区间查找。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201225222929392.png" alt="image-20201225222929392" style="zoom:50%;" />

我们再来看，为什么上述解决思路的时间复杂度是O(n)？ 

第⼀次分区查找，我们需要对⼤⼩为n的数组执⾏分区操作，需要遍历n个元素。第⼆次分区查找，我们只需要对⼤⼩为n/2的数组执⾏分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩⼩为1。

如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是⼀个等⽐数列求和，最后的和等于2n-1。所 以，上述解决思路的时间复杂度就为O(n)。 

你可能会说，我有个很笨的办法，每次取数组中的最⼩值，将其移动到数组的最前⾯，然后在剩下的数组中继续找最⼩值，以此类推，执⾏K次，找到的数据不就是第K⼤元素了吗？不过，时间复杂度就并不是O(n)了，⽽是O(K * n)。你可能会说，时间复杂度前⾯的系数不是可以忽略吗？O(K * n)不就等于O(n)吗？ 

这个可不能这么简单地划等号。当K是⽐较⼩的常量时，⽐如1、2，那最好时间复杂度确实是O(n)；但当K等于n/2或者n时，这种最坏情况下的时间复杂度就是O(n2)了。 













参考

图解排序算法：https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

算法过程动态图：https://visualgo.net/en

