[TOC]

#### 一  思考题

假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这**1000**万数据中？ 我们希望这个功能不要占⽤太多的内存空间，最多不要超过100MB，你会怎么做呢？

#### 二  二分查找介绍

⼆分查找是⼀种⾮常简单易懂的快速查找算法，⽣活中到处可⻅。⽐如说，我们现在来做⼀个猜字游戏。我随机写⼀个0到99之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜⼀次，我就会告诉你猜的⼤了还是⼩了，直到猜中为⽌。你来想 想，如何快速猜中我写的数字呢？ 

假设我写的数字是23，你可以按照下⾯的步骤来试⼀试。（如果猜测范围的数字有偶数个，中间数有两个，就选择较⼩的那个。）

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231165250372.png" alt="image-20201231165250372" style="zoom: 33%;" />

7次就猜出来了，是不是很快？这个例⼦⽤的就是⼆分思想，按照这个思想，即便我让你猜的是0到999的数字，最多也只要10次就能猜中。不信的话，你可以试⼀试。 

这是⼀个⽣活中的例⼦，我们现在回到实际的开发场景中。假设有1000条订单数据，已经按照订单⾦额从⼩到⼤排序，每个 订单⾦额都不同，并且最⼩单位是元。我们现在想知道是否存在⾦额等于19元的订单。如果存在，则返回订单数据，如果不 存在则返回null。 

最简单的办法当然是从第⼀个订单开始，⼀个⼀个遍历这1000个订单，直到找到⾦额等于19元的订单为⽌。但这样查找会⽐ 较慢，最坏情况下，可能要遍历完这1000条记录才能找到。那⽤⼆分查找能不能更快速地解决呢？ 

为了⽅便讲解，我们假设只有10个订单，订单⾦额分别是：8，11，19，23，27，33，45，55，67，98。还是利⽤⼆分思想，每次都与区间的中间数据⽐对⼤⼩，缩⼩查找区间的范围。为了更加直观，我画了⼀张查找过程的图。其中，left和high表示待查找区间的下标，mid表示待查找区间的中间元素下标。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231165744670.png" alt="image-20201231165744670" style="zoom: 33%;" />

看懂这两个例⼦，你现在对⼆分的思想应该掌握得妥妥的了。我这⾥稍微总结升华⼀下，⼆分查找针对的是⼀个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对⽐，将待查找的区间缩⼩为之前的⼀半，直到找到要查找的元素，或者区间被缩⼩为**0**。 

#### 三  O(logn)惊⼈的查找速度 

⼆分查找是⼀种⾮常⾼效的查找算法，⾼效到什么程度呢？我们来分析⼀下它的时间复杂度。我们假设数据⼤⼩是n，每次查找后数据都会缩⼩为原来的⼀半，也就是会除以2。最坏情况下，直到查找区间被缩⼩为空，才停⽌。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231165906297.png" alt="image-20201231165906297" style="zoom:33%;" />

可以看出来，这是⼀个等⽐数列。其中n/2=1时，k的值就是总共缩⼩的次数。⽽每⼀次缩⼩操作只涉及两个数据的⼤⼩⽐较，所以，经过了k次区间缩⼩操作，时间复杂度就是O(k)。通过n/2^k=1，我们可以求得k=log2n，所以时间复杂度就是O(logn)。 

⼆分查找是我们⽬前为⽌遇到的第⼀个时间复杂度为O(logn)的算法。后⾯章节我们还会讲堆、⼆叉树的操作等等，它们的时间复杂度也是O(logn)。我这⾥就再深⼊地讲讲O(logn)这种对数时间复杂度。这是⼀种极其⾼效的时间复杂度，有的时候甚⾄⽐时间复杂度是常量级O(1)的算法还要⾼效。为什么这么说呢？ 

因为logn是⼀个⾮常“恐怖”的数量级，即便n⾮常⾮常⼤，对应的logn也很⼩。⽐如n等于2的32次⽅，这个数很⼤了吧？⼤约是42亿。也就是说，如果我们在42亿个数据中⽤⼆分查找⼀个数据，最多需要⽐较32次。 

我们前⾯讲过，⽤⼤O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是⼀个⾮常⼤的常量值，⽐如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(logn)的算法执⾏效率⾼。 

反过来，对数对应的就是指数。有⼀个⾮常著名的“阿基⽶德与国王下棋的故事”，你可以⾃⾏搜索⼀下，感受⼀下指数的“恐怖”。这也是为什么我们说，指数时间复杂度的算法在⼤规模数据⾯前是⽆效的。

#### 四  代码实现

##### 1  递归法

````java
	// ⼆分查找的递归实现 
	public int bsearch(int[] nums, int n, int val) { 
    	return bsearchInternally(nums, val, 0, n-1); 
    }

	public int bsearchInternally(int[] nums, int val, int left, int right) {
        // 递归退出条件
        if (left <= right) {
            // 计算中间节点，防止数值溢出
            int mid = left + (right - left) / 2;
            // 如果中间节点恰好是要查找的值，则可以直接退出
            if (nums[mid] == val) {
                return mid;
            }
            // 如果中间节点小于要查找的值，因此需要从又半部分查找
            if (nums[mid] < val) {
                // 这里需要 +1 防止死循环
                left = mid + 1;
                // 递归调用
                return binarySearch1(nums, val, left, right);
            }
            if (nums[mid] > val) {
                // 这里需要 -1 防止死循环
                right = mid - 1;
                // 递归调用
                return binarySearch1(nums, val, left, right);
            }
        }
        return -1;
	}
````

由于递归需要频繁的入栈出栈,所以效率比较低,改为循环实现

##### 2  循环法

````java
	/**
     * 由于递归需要频繁的入栈出栈,所以效率比较低,改为循环实现
     */
    public int binarySearch2(int[] nums, int val) {
        int left = 0, right = nums.length - 1;
        // 这里判断条件需要是 <=
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == val) {
                return mid;
            } else if (nums[mid] < val) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }	
````

##### 3  代码说明

这个代码我稍微解释⼀下，left、high、mid都是指数组下标，其中 left 和 high 表示当前查找的区间范围，初始left = 0， high=n - 1。mid表示[left,high]的中间位置。我们通过对⽐ a[mid] 与 value 的⼤⼩，来更新接下来要查找的区间范围，直到找到或者区间缩⼩为0，就退出。如果你有⼀些编程基础，看懂这些应该不成问题。现在，我就着重强调⼀下容易出错的**3**个地⽅。 

1. 循环退出条件注意是 left <= high，⽽不是 left < high。 

2. mid的取值 

实际上，mid = (left + high) / 2 这种写法是有问题的。因为如果 left 和 high ⽐较⼤的话，两者之和就有可能会溢出。改进的⽅法是将 mid 的计算⽅式写成 left + (high - left) / 2。更进⼀步，如果要将性能优化到极致的话，我们可以将这⾥的除以2操作转化成位运算 left + ((high-left) >> 1)。因为相⽐除法运算来说，计算机处理位运算要快得多。 

3. left和high的更新 

left=mid+1，high=mid-1。注意这⾥的+1和-1，如果直接写成left=mid或者high=mid，就可能会发⽣死循环。⽐如，当 high=3，left=3 时，如果a[3]不等于value，就会导致⼀直循环不退出。 

如果你留意我刚讲的这三点，我想⼀个简单的⼆分查找你已经可以实现了。

#### 五  ⼆分查找应⽤场景的局限性 

前⾯我们分析过，⼆分查找的时间复杂度是O(logn)，查找数据的效率⾮常⾼。不过，并不是什么情况下都可以⽤⼆分查找，它的应⽤场景是有很⼤局限性的。那什么情况下适合⽤⼆分查找，什么情况下不适合呢？ 

**（1）⼆分查找依赖的是顺序表结构，简单点说就是数组。** 

那⼆分查找能否依赖其他数据结构呢？⽐如链表。答案是不可以的，主要原因是⼆分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是O(1)，⽽链表随机访问的时间复杂度是O(n)。所以，如果数据使⽤链表存储，⼆分查找的时间复杂就会变得很⾼。 

⼆分查找只能⽤在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则⽆法应⽤⼆分查找。

**（2）⼆分查找针对的是有序数据。** 

⼆分查找对这⼀点的要求⽐较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前⾯章节⾥我们讲到，排序的时间复杂度最低是O(nlogn)。所以，如果我们针对的是⼀组静态的数据，没有频繁地插⼊、删除，我们可以进⾏⼀次排序，多次⼆分查找。这样排序的成本可被均摊，⼆分查找的边际成本就会⽐较低。 

但是，如果我们的数据集合有频繁的插⼊和删除操作，要想⽤⼆分查找，要么每次插⼊、删除操作之后保证数据仍然有序，要么在每次⼆分查找之前都先进⾏排序。针对这种动态数据集合，⽆论哪种⽅法，维护有序的成本都是很⾼的。 

所以，⼆分查找只能⽤在插⼊、删除操作不频繁，⼀次排序多次查找的场景中。针对动态变化的数据集合，⼆分查找将不再适⽤。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到⼆叉树那⼀节我会详细讲。 

**（3）数据量太⼩不适合⼆分查找。** 

如果要处理的数据量很⼩，完全没有必要⽤⼆分查找，顺序遍历就⾜够了。⽐如我们在⼀个⼤⼩为10的数组中查找⼀个元素，不管⽤⼆分查找还是顺序遍历，查找速度都差不多。只有数据量⽐较⼤的时候，⼆分查找的优势才会⽐较明显。 

不过，这⾥有⼀个例外。如果数据之间的⽐较操作⾮常耗时，不管数据量⼤⼩，我都推荐使⽤⼆分查找。⽐如，数组中存储的都是⻓度超过300的字符串，如此⻓的两个字符串之间⽐对⼤⼩，就会⾮常耗时。我们需要尽可能地减少⽐较次数，⽽⽐较次数的减少会⼤⼤提⾼性能，这个时候⼆分查找就⽐顺序遍历更有优势。 

**（4）数据量太⼤也不适合⼆分查找。** 

⼆分查找的底层需要依赖数组这种数据结构，⽽数组为了⽀持随机访问的特性，要求内存空间连续，对内存的要求⽐较苛刻。 

⽐如，我们有1GB⼤⼩的数据，如果希望⽤数组来存储，那就需要1GB的连续内存空间。注意这⾥的“连续”⼆字，也就是说，即便有2GB的内存空间剩余，但是如果这剩余的2GB内存空间都是零散的，没有连续的1GB⼤⼩的内存空间，那照样⽆法申请⼀个1GB⼤⼩的数组。⽽我们的⼆分查找是作⽤在数组这种数据结构之上的，所以太⼤的数据⽤数组存储就⽐较吃⼒了，也就不能⽤⼆分查找了

#### 六  解答开篇 

看下开篇的思考题：如何在1000万个整数中快速查找某个整数？ 

这个问题并不难。我们的内存限制是100MB，每个数据⼤⼩是8字节，最简单的办法就是将数据存储在数组中，内存占⽤差不多是80MB，符合内存的限制。借助今天讲的内容，我们可以先对这1000万数据从⼩到⼤排序，然后再利⽤⼆分查找算法，就可以快速地查找想要的数据了。 

看起来这个问题并不难，很轻松就能解决。实际上，它暗藏了“⽞机”。如果你对数据结构和算法有⼀定了解，知道散列表、⼆叉树这些⽀持快速查找的动态数据结构。你可能会觉得，⽤散列表和⼆叉树也可以解决这个问题。实际上是不⾏的。 

虽然⼤部分情况下，⽤⼆分查找可以解决的问题，⽤散列表、⼆叉树都可以解决。但是，我们后⾯会讲，不管是散列表还是⼆ 叉树，都会需要⽐较多的额外的内存空间。如果⽤散列表或者⼆叉树来存储这1000万的数据，⽤100MB的内存肯定是存不下的。⽽⼆分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储⽅式，所以刚好能在限定的内存⼤⼩下解决这个问题。 

#### 七  相关算法

##### 1  [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

````java
示例 1:
输入: 4
输出: 2

示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
````

（1）解法1

````java
public int mySqrt(int x) {
    	// 边界条件判断
        if (x <= 0) {
            return 0;
        }
    	// 根据二分法求解，平方根的值一定在 1 - x 之间
        int left = 1, right = x;
        int mid = -1;
        while (left <= right) {
            // 计算中间值
            mid = left + (right - left) / 2;
            // 这里要用除法，否则可能会超出整型最大值
            if (mid  == x/mid) {
                return mid;
            // 需要同时判断mid和mid+1  
            } else if (x/mid >= mid && x/(mid + 1) < (mid + 1)){
                return mid;
            }else if (mid > x/mid) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return mid;
    }
````

（2）解法二，简单写法

````java
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
````

