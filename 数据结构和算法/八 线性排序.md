[TOC]

#### 一  桶排序（**Bucket sort**）

桶排序，顾名思义，会⽤到“桶”，核⼼思想是将要排序的数据分到⼏个**有序**的桶⾥，每个桶⾥的数据再单独进⾏排序。桶内排完序之后，再把每个桶⾥的数据按照顺序依次取出，组成的序列就是有序的了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231111036711.png" alt="image-20201231111036711" style="zoom: 33%;" />

桶排序的时间复杂度为什么是O(n)呢？我们⼀块⼉来分析⼀下。 

如果要排序的数据有 **n** 个，我们把它们均匀地划分到 **m** 个桶内，每个桶⾥就有 **k=n/m** 个元素。每个桶内部使⽤快速排序，时间复杂度为 **O(k * logk)** 。m 个桶排序的时间复杂度就是 **O(m * k * logk)** ，因为k=n/m，所以整个桶排序的时间复杂度就是 **O(n * log(n/m))** 。当桶的个数m接近数据个数时，log(n/m)就是⼀个⾮常⼩的常量，这个时候桶排序的时间复杂度接近O(n)。 

桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？ 

答案当然是否定的。为了让你轻松理解桶排序的核⼼思想，我刚才做了很多假设。实际上，桶排序对要排序数据的要求是⾮常苛刻的。 

1. ⾸先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的⼤⼩顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进⾏排序。 

2. 其次，数据在各个桶之间的分布是⽐较均匀的。如果数据经过桶的划分之后，有些桶⾥的数据⾮常多，有些⾮常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到⼀个桶⾥，那就退化为O(nlogn)的排序算法了。 

桶排序⽐较适合⽤在 **外部排序** 中。所谓的外部排序就是数据存储在外部磁盘中，数据量⽐较⼤，内存有限，⽆法将数据全部加载到内存中。 

⽐如说我们**有10GB的订单数据，我们希望按订单⾦额（假设⾦额都是正整数）进⾏排序，但是我们的内存有限，只有⼏百MB，没办法⼀次性把10GB的数据都加载到内存中**。这个时候该怎么办呢？ 

现在我来讲⼀下，如何借助桶排序的处理思想来解决这个问题。 

我们可以先扫描⼀遍⽂件，看订单⾦额所处的数据范围。假设经过扫描之后我们得到，订单⾦额最⼩是1元，最⼤是10万元。我们将所有订单根据⾦额划分到100个桶⾥，第⼀个桶我们存储⾦额在1元到1000元之内的订单，第⼆桶存储⾦额在1001元到2000元之内的订单，以此类推。每⼀个桶对应⼀个⽂件，并且按照⾦额范围的⼤⼩顺序编号命名（00，01，02…99）。 

理想的情况下，如果订单⾦额在1到10万之间均匀分布，那订单会被均匀划分到100个⽂件中，每个⼩⽂件中存储⼤约100MB的订单数据，我们就可以将这100个⼩⽂件依次放到内存中，⽤快排来排序。等所有⽂件都排好序之后，我们只需要按照⽂件编号，从⼩到⼤依次读取每个⼩⽂件中的订单数据，并将其写⼊到⼀个⽂件中，那这个⽂件中存储的就是按照⾦额从⼩到⼤排序的订单数据了。 

不过，你可能也发现了，订单按照⾦额在1元到10万元之间并不⼀定是均匀分布的 ，所以10GB订单数据是⽆法均匀地被划分到100个⽂件中的。有可能某个⾦额区间的数据特别多，划分之后对应的⽂件就会很⼤，没法⼀次性读⼊内存。这⼜该怎么办呢？

针对这些划分之后还是⽐较⼤的⽂件，我们可以继续划分，⽐如，订单⾦额在1元到1000元之间的⽐较多，我们就将这个区间 继续划分为10个⼩区间，1元到100元，101元到200元，201元到300元…901元到1000元。如果划分之后，101元到200元之间的订单还是太多，⽆法⼀次性读⼊内存，那就继续再划分，直到所有的⽂件都能读⼊内存为⽌。 

#### 二  计数排序（**Counting sort**） 

我个⼈觉得，计数排序其实是桶排序的⼀种特殊情况。当要排序的n个数据，**所处的范围并不⼤的时候**，⽐如最⼤值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。 

我们都经历过⾼考，⾼考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有50万考⽣，如何通过成绩快速排序得出名次呢？ 

考⽣的满分是900分，最⼩是0分，这个数据的范围很⼩，所以我们可以分成901个桶，对应分数从0分到900分。根据考⽣的成绩，我们将这50万考⽣划分到这901个桶⾥。桶内的数据都是分数相同的考⽣，所以并不需要再进⾏排序。我们只需要依次扫描每个桶，将桶内的考⽣依次输出到⼀个数组中，就实现了50万考⽣的排序。因为只涉及扫描遍历操作，所以时间复杂度是O(n)。 

计数排序的算法思想就是这么简单，跟桶排序⾮常类似，只是桶的⼤⼩粒度不⼀样。不过，为什么这个排序算法叫**“**计数**”**排序呢？**“**计数**”**的含义来⾃哪⾥呢？

想弄明⽩这个问题，我们就要来看计数排序算法的实现⽅法。我还拿考⽣那个例⼦来解释。为了⽅便说明，我对数据规模做了简化。假设只有8个考⽣，分数在0到5分之间。这8个考⽣的成绩我们放在⼀个数组A[8]中，它们分别是： 

````java
2，5，3，0，2，3，0，3
````

考⽣的成绩从0到5分，我们使⽤⼤⼩为6的数组C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到C[6]的值。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231120031731.png" alt="image-20201231120031731" style="zoom:33%;" />

从图中可以看出，分数为3分的考⽣有3个，⼩于3分的考⽣有4个，所以，成绩为3分的考⽣在排序之后的有序数组R[8]中，会保存下标4，5，6的位置。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231120143783.png" alt="image-20201231120143783" style="zoom:33%;" />

那我们如何快速计算出，每个分数的考⽣在有序数组中对应的存储位置呢？这个处理⽅法⾮常巧妙，很不容易想到。 

思路是这样的：我们对C[6]数组顺序求和，C[6]存储的数据就变成了下⾯这样⼦。**C[k]⾥存储⼩于等于分数k的考⽣个数。** 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231125119826.png" alt="image-20201231125119826" style="zoom: 50%;" />

有了前⾯的数据准备之后，现在我就要讲计数排序中最复杂、最难理解的⼀部分了，请集中精⼒跟着我的思路！ 

我们从后到前依次扫描数组A。⽐如，当扫描到3时，我们可以从数组C中取出下标为3的值7，也就是说，到⽬前为⽌，包括⾃⼰在内，分数⼩于等于3的考⽣有7个，也就是说3是数组R中的第7个元素（也就是数组R中下标为6的位置）。当3放⼊到数组R中后，⼩于等于3的元素就只剩下了6个了，所以相应的C[3]要减1，变成6。 

以此类推，当我们扫描到第2个分数为3的考⽣的时候，就会把它放⼊数组R中的第6个元素的位置（也就是下标为5的位置）。 

当我们扫描完整个数组A后，数组R内的数据就是按照分数从⼩到⼤有序排列的了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231125408818.png" alt="image-20201231125408818" style="zoom: 50%;" />

````java
	//计数排序，a是数组，n是数组⼤⼩。假设数组中存储的都是⾮负整数。
    public void countingSort(int[] a, int n) {
        if (n <= 1) return;
        //查找数组中数据的范围
        int max = a[0];
        for (int i = 1; i < n; ++i) {
            if (max < a[i]) {
                max = a[i];
            }
        }
        // 根据数据范围创建数组
        // 申请⼀个计数数组c，下标⼤⼩[0, max]，初始化都设置为0
        int[] c = new int[max + 1];
        for (int i = 0; i <= max; ++i) {
            c[i] = 0;
        }
        //计算每个元素的个数，放⼊c中
        for (int i = 0; i < n; ++i) {
            c[a[i]]++;
        }
        //依次累加
        for (int i = 1; i <= max; ++i) {
            c[i] = c[i - 1] + c[i];
        }
        //临时数组r，存储排序之后的结果
        int[] r = new int[n];

        //计算排序的关键步骤，有点难理解
        for (int i = n - 1; i >= 0; --i) {
            int index = c[a[i]] - 1;
            r[index] = a[i];
            c[a[i]]--;
        }
        //将结果拷⻉给a数组
        for (int i = 0; i < n; ++i) {
            a[i] = r[i];
        }
    }
````

总结⼀下，计数排序只能⽤在数据范围不⼤的场景中，如果数据范围**k**⽐要排序的数据**n**⼤很多，就不适合⽤计数排序了。 

⽽且，计数排序只能给⾮负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对⼤⼩的情况下，转化为⾮负整数。

⽐如，还是拿考⽣这个例⼦。如果考⽣成绩精确到⼩数后⼀位，我们就需要将所有的分数都先乘以10，转化成整数，然后再 放到9010个桶内。再⽐如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成⾮负整数。 

#### 三  基数排序（**Radix sort**） 

我们再来看这样⼀个排序问题。假设我们有10万个⼿机号码，希望将这10万个⼿机号码从⼩到⼤排序，你有什么⽐较快速的排序⽅法呢？ 

我们之前讲的快排，时间复杂度可以做到O(nlogn)，还有更⾼效的排序算法吗？桶排序、计数排序能派上⽤场吗？⼿机号码有11位，范围太⼤，显然不适合⽤这两种排序算法。针对这个排序问题，有没有时间复杂度是O(n)的算法呢？现在我就来介绍⼀种新的排序算法，基数排序。 

刚刚这个问题⾥有这样的规律：假设要⽐较两个⼿机号码a，b的⼤⼩，如果在前⾯⼏位中，a⼿机号码已经⽐b⼿机号码⼤了，那后⾯的⼏位就不⽤看了。 

借助稳定排序算法，这⾥有⼀个巧妙的实现思路。还记得我们第11节中，在阐述排序算法的稳定性的时候举的订单的例⼦吗？ 

我们这⾥也可以借助相同的处理思路，先按照最后⼀位来排序⼿机号码，然后，再按照倒数第⼆位重新排序，以此类推，最后 

按照第⼀位重新排序。经过11次排序之后，⼿机号码就都有序了。 

⼿机号码稍微有点⻓，画图⽐较不容易看清楚，我⽤字符串排序的例⼦，画了⼀张基数排序的过程分解图，你可以看下。 

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201231131838091.png" alt="image-20201231131838091" style="zoom:50%;" />

注意，这⾥按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是⾮稳定排序算法，那最后⼀次排序只会考虑最⾼位的⼤⼩顺序，完全不管其他位的⼤⼩关系，那么低位的排序就完全没有意义了。 

根据每⼀位来排序，我们可以⽤刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到O(n)。如果要排序的数据有k位，那我们就需要k次桶排序或者计数排序，总的时间复杂度是O(k*n)。当k不⼤的时候，⽐如⼿机号码排序的例⼦，k最⼤就是11，所以基数排序的时间复杂度就近似于O(n)。 

实际上，有时候要排序的数据并不都是等⻓的，⽐如我们排序⽜津字典中的20万个英⽂单词，最短的只有1个字⺟，最⻓的我特意去查了下，有45个字⺟，中⽂翻译是尘肺病。对于这种不等⻓的数据，基数排序还适⽤吗？ 

实际上，我们可以把所有的单词补⻬到相同⻓度，位数不够的可以在后⾯补**“0”**，因为根据ASCII值，所有字⺟都⼤于“0”，所以补“0”不会影响到原有的⼤⼩顺序。这样就可以继续⽤基数排序了。 

我来总结⼀下，基数排序对要排序的数据是有要求的，需要可以分割出独⽴的**“**位**”**来⽐较，⽽且位之间有递进的关系，如果**a**数据的⾼位⽐**b**数据⼤，那剩下的低位就不⽤⽐较了。除此之外，每⼀位的数据范围不能太⼤，要可以⽤线性排序算法来排序，否则，基数排序的时间复杂度就⽆法做到**O(n)**了。 

#### 四  开放问题

##### 1  如何根据年龄给100万⽤户排序？

使用计数排序思路，根据年龄给100万⽤户排序，就类似按照成绩给50万考⽣排序。我们假设年龄的范围最⼩1岁，最⼤不超过120岁。我 们可以遍历这100万⽤户，根据年龄将其划分到这120个桶⾥，然后依次顺序遍历这120个桶中的元素。这样就得到了按照年龄排序的100万⽤户数据。 

##### 2  对D，a，F，B，c，A，z这个字符串进⾏排序，要求将其中所有⼩写字⺟都排在⼤写字⺟的前⾯，但⼩写字⺟内部和⼤写字⺟内部不要求有序。⽐如经过排序之后为a，c，z，D，F，B，A，

思路1：⽤两个指针a、b：a指针从头开始往后遍历，遇到⼤写字⺟就停下，b从后往前遍历，遇到⼩写字⺟就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。 

对于⼩写字⺟放前⾯，数字放中间，⼤写字⺟放后⾯，可以先将数据分为⼩写字⺟和⾮⼩写字⺟两⼤类，进⾏如上交换后再在⾮⼩写字⺟区间内分为数字和⼤写字⺟做同样处理 

思路2：利⽤桶排序思想，弄⼩写，⼤写，数字三个桶，遍历⼀遍，都放进去，然后再从桶中取出来就⾏了。相当于遍历了两遍，复杂度O(n) 

#### 五  总结

桶排序和计数排序的排序思想是⾮常相似的，都是针对范围不⼤的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成⾼低位，位之间有递进关系。⽐较两个数，我们只需要⽐较⾼位，⾼位相同的再⽐较低位。⽽且每⼀位的数据范围不能太⼤，因为基数排序算法需要借助桶排序或者计数排序来完成每⼀个位的排序⼯作。 