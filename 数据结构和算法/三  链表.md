[TOC]



### 一  链表结构

从**底层的存储结构**上来看一看。

为了直观地对比，我画了一张图。从图中我们看到，数组需要一块**连续的内存空间**来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。

而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组**零散的内存块**串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/d5d5bee4be28326ba3c28373808a62cd.jpg" alt="img" style="zoom:50%;" />

#### 1  单链表

链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的**结点**。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作**后继指针next**。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

从单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作**头结点**，把最后一个结点叫作**尾结点**。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个**空地址NULL**，表示这是链表上最后一个结点。

与数组一样，链表也支持数据的查找、插入和删除操作。

我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/452e943788bdeea462d364389bd08a17.jpg" alt="img" style="zoom:50%;" />

但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。

你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第k位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度。

#### 2  循环链表

**循环链表是一种特殊的单链表**。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/86cb7dc331ea958b0a108b911f38d155.jpg" alt="img" style="zoom:50%;" />

和单链表相比，**循环链表**的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的[约瑟夫问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

#### 3  双向链表

单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;" />

从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

- 双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是O(1)了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。

（1）删除操作

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

- 删除结点中“值等于某个给定值”的结点；
- 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。

````java
public void deleteNode(ListNode head, int value){
        if (head == null){
            return;
        }
        if (head.val == value){
            head = head.next;
            return;
        }
        ListNode node = head;
        while (node.next != null){
            if (node.next.val == value){
                node.next = node.next.next;
            }
            node = node.next;
        }
    }
````

尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。

对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p->next=q，说明p是q的前驱结点。

但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了！

同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。

除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过LinkedHashMap这个容器。如果你深入研究LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。

实际上，这里有一个更加重要的知识点需要你掌握，那就是**用空间换时间**的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

所以，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

#### 4  链表VS数组性能大比拼

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/4f63e92598ec2551069a0eef69db7168.jpg" alt="img" style="zoom:50%;" />

数组简单易用，在实现上使用的是连续的内存空间，**可以借助CPU的缓存机制**，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。

**数组的缺点是大小固定**，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致**内存不足（out of memory）**。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

你可能会说，我们Java中的ArrayList容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。

我举一个稍微极端的例子。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷贝到新申请的空间上。听起来是不是就很耗时？

除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。

所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。

### 二  基于链表实现LRU缓存淘汰算法

思路是这样的：

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：

- 如果此时缓存未满，则将此结点直接插入到链表的头部；
- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这样我们就用链表实现了一个LRU缓存，是不是很简单？

现在我们来看下m缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O(n)。

````java
/**
 * 实现一个LRU链表，链表头部是最新的数据，链表尾部是最久的数据
 *
 * @param <T>
 */
public class LRULinkList<T> {
    private ListNode<T> head;

    private static final int defaultLength = 10;

    private int length;

    private int capacity;

    // 构造函数
    public LRULinkList() {
        head = new ListNode<>();
        length = 0;
        capacity = defaultLength;
    }

    public LRULinkList(int capacity) {
        head = new ListNode<>();
        length = 0;
        this.capacity = capacity;
    }

    /**
     * 获取某个元素
     */
    public void get(T data) {
        // 获取已经存在的节点的前一个节点
        ListNode preNode = findPreNode(data);
        if (preNode != null) {
            // 如果存在前一个节点，则删除要查找的节点，并插入到链表头部
            ListNode<T> node = deleteNodeNext(preNode);
            insertHead(node);
        } else {
            // 如果不存在
            if (length >= capacity) {
                deleteTailNode(head);
            }
            // 插入到链表头部
            insertHead(new ListNode<>(data, null));
        }
    }

    // 删除尾部节点
    private void deleteTailNode(ListNode<T> head) {
        ListNode<T> node = head;
        while (node != null && node.getNext() != null && node.getNext().getNext() != null) {
            node = node.getNext();
        }
        node.setNext(null);
        length--;
    }

    // 插入到头部
    private void insertHead(ListNode<T> node) {
        node.setNext(head.getNext());
        head.setNext(node);
        length++;
    }

    // 删除指定节点
    private ListNode<T> deleteNodeNext(ListNode preNode) {
        ListNode<T> node = preNode.getNext();
        preNode.setNext(node.getNext());
        length--;
        return node;
    }

    /**
     * 获取要查找的节点的前一个节点
     */
    private ListNode findPreNode(T data) {
        ListNode node = head;
        while (node.getNext() != null) {
            if (node.getNext().equals(data)) {
                return node;
            }
            node = node.getNext();
        }
        return null;
    }
}

````

### 三  判断通过单链表来存储的字符串，是否是一个回文串呢

https://leetcode-cn.com/problems/palindrome-linked-list/

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

#### 1  通过快慢指针，反转链表

整个流程可以分为以下五个步骤：

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

````java
// 主函数，判断是否回文链表，入参为链表头结点
public boolean isPalindrome(ListNode head) {
        // 如果链表为空或者只有一个节点，则是回文
        if (head == null || head.next == null) {
            return true;
        }
        // 获取中间节点
        ListNode midNode = findMidNode(head);
        // 反转链表
        ListNode secHead = reverse(midNode);
        // 判断是否回文
        ListNode node1 = head;
        ListNode node2 = secHead;
        boolean result = true;
        while (result && node2 != null) {
            if (node1.val != node2.val) {
                result = false;
            }
            node1 = node1.next;
            node2 = node2.next;
        }
        // 还原链表
        reverse(secHead);
        return result;
}

// 反转链表
private ListNode reverse(ListNode midNode) {
        // 新的头结点
        ListNode newHead = null;
        // 遍历链表
        ListNode node = midNode;
        while (node != null) {
            // 需要保存当前遍历的节点的下一个节点
            ListNode tmp = node.next;
            // 反转
            node.next = newHead;
            newHead = node;
            // 遍历下一个节点
            node = tmp;
        }
        return newHead;
}

// 通过快慢指针定位到链表中间节点
private ListNode findMidNode(ListNode head) {
        ListNode slowNode = head;
        ListNode quickNode = head;
        while (quickNode != null && quickNode.next != null) {
            slowNode = slowNode.next;
            quickNode = quickNode.next.next;
        }
        return slowNode;
}
````

**复杂度分析**

时间复杂度：O(n)，其中 n 指的是链表的元素个数。

- 第一步： 遍历链表并将值复制到数组中，O(n)。

- 第二步：双指针判断是否为回文，执行了 O(n/2)次的判断，即 O(n)。

总的时间复杂度：O(2n) = O(n)。
空间复杂度：O(1)

#### 2  通过数组双向遍历

确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。

````Java
public boolean isPalindrome(ListNode head) {
        List<Integer> vals = new ArrayList<Integer>();
        // 将链表的值复制到数组中
        ListNode currentNode = head;
        while (currentNode != null) {
            vals.add(currentNode.val);
            currentNode = currentNode.next;
        }
        // 使用双指针判断是否回文
        int front = 0;
        int back = vals.size() - 1;
        while (front < back) {
            if (!vals.get(front).equals(vals.get(back))) {
                return false;
            }
            front++;
            back--;
        }
        return true;
}
````

**复杂度分析**

时间复杂度：O(n)，其中 n 指的是链表的元素个数。

- 第一步： 遍历链表并将值复制到数组中，O(n)。

- 第二步：双指针判断是否为回文，执行了 O(n/2)次的判断，即 O(n)。

总的时间复杂度：O(2n) = O(n)。
空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。

### 四  写链表代码技巧

#### 1  技巧一：理解指针或引用的含义

不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是**存储所指对象的内存地址**。

接下来，我会拿C语言中的“指针”来讲解，如果你用的是Java或者其他没有指针的语言也没关系，你把它理解成“引用”就可以了。实际上，对于指针的理解，你只需要记住下面这句话就可以了：

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

这句话听起来还挺拗口的，你可以先记住。我们回到链表代码的编写过程中，我来慢慢给你解释。

在编写链表代码的时候，我们经常会有这样的代码：

````java
p.next=q
````

这行代码是说，p结点中的next指针存储了q结点的内存地址。

还有一个更复杂的，也是我们写链表代码经常会用到的：

````java
p.next=p.next.next
````

这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址，最终结果是将p.next节点删除了。

#### 2  技巧二：警惕指针丢失和内存泄漏

不知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，我们在写的时候，一定注意不要弄丢了指针。

指针往往都是怎么弄丢的呢？我拿单链表的插入操作为例来给你分析一下。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/05a4a3b57502968930d517c934347c6e.jpg" alt="img" style="zoom:50%;" />

如图所示，我们希望在结点a和相邻的结点b之间插入结点x，假设当前指针p指向结点a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。

````java
p.next = x;  // 将p的next指针指向x结点；
x.next = p.next;  // 将x的结点的next指针指向b结点；
````

`p.next`指针在完成第一步操作之后，已经不再指向结点b了，而是指向结点x。第2行代码相当于将x赋值给x->next，自己指向自己。因此，整个链表也就断成了两半，从结点b往后的所有结点都无法访问到了。

对于有些语言来说，比如C语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们**插入结点时，一定要注意操作的顺序**，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第1行和第2行代码的顺序颠倒一下就可以了。

同理，**删除链表结点时，也一定要记得手动释放内存空间**，否则，也会出现内存泄漏的问题。当然，对于像Java这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

#### 3  技巧三：利用哨兵简化实现难度

首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点p后面插入一个新的结点，只需要下面两行代码就可以搞定。

````
new_node->next = p->next;
p->next = new_node;
````

但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中head表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。

````java
if (head == null) {
  head = new_node;
}
````

我们再来看单链表结点删除操作。如果要删除结点p的后继结点，我们只需要一行代码就可以搞定。

````
p->next = p->next->next;
````

但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不work了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：

````java
if (head.next == null) {
   head = null;
}
````

从前面的一步一步分析，我们可以看出，**针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理**。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？

还记得如何表示一个空链表吗？head=null表示链表中没有结点了。其中head表示头结点指针，指向链表中的第一个结点。

如果我们引入**哨兵结点**，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。

我画了一个带头链表，你可以发现，**哨兵结点是不存储数据的**。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/7d22d9428bdbba96bfe388fe1e3368c7.jpg" alt="img" style="zoom:50%;" />

实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

#### 4  技巧四：重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生Bug。链表代码也不例外。要实现没有Bug的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。

我经常用来检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

当你写完链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面我列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。

当然，边界条件不止我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你自己去思考，不过套路都是一样的。

实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

#### 5  技巧五：举例画图，辅助思考

对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，**举例法**和**画图法**。

你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/4a701dd79b59427be654261805b349f8.jpg" alt="img" style="zoom:50%;" />

#### 6  技巧六：多写多练，没有捷径

如果你已经理解并掌握了我前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为我最开始学的时候，这种状况也持续了一段时间。

所以，我精选了5个常见的链表操作。你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第n个结点
- 求链表的中间结点

### 五  常见链表算法题

练习题LeetCode对应编号：206，141，21，19，876

#### 1  单链表反转

示例: 
输入:   1->2->3->4->5->NULL
输出:   5->4->3->2->1->NULL 

**（1）循环法**

* 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。
* 由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。
* 在更改引用之前，还需要另一个指针来存储下一个节点。
* 不要忘记在最后返回新的头引用！

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt="img" style="zoom:50%;" />

```java
public ListNode reverseList(ListNode head) {
    	// 边界条件判断
        if (head == null || head.next == null) {
            return head;
        }
        // 新的头结点
        ListNode newHead = null;
        // 遍历node
        ListNode node = head;
        while (node != null) {
            // 保存node的下一个节点，以便可以进行下一次遍历
            ListNode temp = node.next;
            // node的next指向新的头结点，实现节点反转
            node.next = newHead;
            newHead = node;
            // 遍历下一个节点
            node = temp;
        }
        return newHead;
}
```

**（2）递归法**


不妨假设链表为1 -> 2 -> 3 -> 4 -> 5 -> null
* 按照递归，当执行reverseList（5）的时候返回了5这个节点，reverseList(4)中的newHead就是5这个节点，
* 我们看看reverseList（4）接下来执行完之后，5->next = 4, 4->next = null。
* 这时候返回了newHead这个节点，也就是链表5->4->null，接下来执行reverseList（3），代码解析为4->next = 3,3->next = null，
* 这个时候newHead就变成了，5->4->3->null, reverseList(2), reverseList(1)依次类推，newHead就是:5->4->3->2->1->null

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif" alt="img" style="zoom:50%;" />

````java
public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
}
````

#### 2 链表中环的检测

给定一个链表，判断链表中是否有环。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/circularlinkedlist.png" alt="img" style="zoom:50%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="zoom:50%;" />

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**（1）快慢指针**

````java
public boolean hasCycle(ListNode head) {
        // 边界条件
        if (head == null || head.next == null) {
            return false;
        }
        // 慢指针
        ListNode slow = head;
        // 快指针
        ListNode fast = head.next.next;
        while (fast != null && fast.next != null) {
            // 如果快指针追上了慢指针，则表示有环
            if (fast == slow) {
                return true;
            }
            // 慢指针每次移动一位
            slow = slow.next;
            // 快指针移动两位
            fast = fast.next.next;
        }
        return false;
}
````

复杂度分析

时间复杂度：O(n)，其中 n 是链表中的节点数。

- 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。

- 当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。

空间复杂度：O(1)。我们只使用了两个指针的额外空间。

**（2）哈希表**

遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

````java
public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
}
````

#### 3  两个有序的链表合并

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

````
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
````

**（1） 迭代法**

首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。

我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：

- 如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。
- 否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

````java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建哨兵指针
        ListNode head = new ListNode();
    	// 向后遍历的节点
        ListNode node = head;
        // 都不为空时合并
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                node.next = new ListNode(l1.val);
                l1 = l1.next;
            } else {
                node.next = new ListNode(l2.val);
                l2 = l2.next;
            }
            node = node.next;
        }
    	// 说明l2已经遍历完了，但是l1未遍历完
        while (l1 != null) {
            node.next = new ListNode(l1.val);
            l1 = l1.next;
            node = node.next;
        }
		// 说明l1已经遍历完了，但是l2未遍历完
        while (l2 != null) {
            node.next = new ListNode(l2.val);
            l2 = l2.next;
            node = node.next;
        }
    	// 返回头结点
        return head.next;
}
````

**（2）递归法**

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201104145332266.png" alt="image-20201104145332266" style="zoom:50%;" />

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

````java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    	// 递归结束条件
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            // 递归
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
}
````

#### 4 删除链表倒数第n个结点

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
（1）双指针

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/p3.png" alt="p3" style="zoom:50%;" />


````java
 public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null){
            return null;
        }
        // 哨兵节点，指向头结点
        ListNode temp = new ListNode(0);
        temp.next = head;
        ListNode first = temp,scend = temp;
        // first指针先移动n位,考虑删除的是头结点，因此需要保证first节点移动了n + 1次
        for (int i = 0;i <= n;i++){
            first = first.next;
        }
        // first和second一起移动到最后
        while (first != null){
            first = first.next;
            scend = scend.next;
        }
        // second的位置就是倒数第n的位置
        scend.next = scend.next.next;
        return temp.next;
    }
````

**（2）使用栈**

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

````java
public ListNode removeNthFromEnd(ListNode head, int n) {
    	// 创建哨兵节点，next指向头结点
        ListNode dummy = new ListNode(0, head);
    	// 创建一个栈
        Deque<ListNode> stack = new LinkedList<ListNode>();
        ListNode cur = dummy;
    	// 依次入栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
    	// 弹出n个节点
        for (int i = 0; i < n; ++i) {
            stack.pop();
        }
    	// 弹出后，目前的栈顶节点即要删除节点的前驱节点
        ListNode prev = stack.peek();
    	// 删除节点
        prev.next = prev.next.next;
        ListNode ans = dummy.next;
        return ans;
}

````

#### 5  求链表的中间结点

**（1）快慢指针法**

用两个指针 `slow` 与 `fast` 一起遍历链表。`slow` 一次走一步，`fast` 一次走两步。那么当 `fast` 到达链表的末尾时，`slow` 必然位于中间。因为快指针移动的步数是慢指针的2倍

````java
public ListNode middleNode(ListNode head) {
		// 边界条件判断
        if (head == null || head.next == null){
            return head;
        }
        // 定义快慢指针
        ListNode slow = head;
        ListNode fast = head;
    	// 快指针每次移动两位，慢指针每次移动一位
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
````

复杂度分析

- 时间复杂度：O(N)，其中 N是给定链表的结点数目。

- 空间复杂度：O(1)，只需要常数空间存放 slow 和 fast 两个指针。

**（2）数组**

链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。

````java
public ListNode middleNode(ListNode head) {
        ListNode[] A = new ListNode[100];
        int t = 0;
    	// 存入数组中
        while (head != null) {
            A[t++] = head;
            head = head.next;
        }
        return A[t / 2];
}
````

**（3）单指针遍历**

对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。

````java
public ListNode middleNode(ListNode head) {
        int n = 0;
        ListNode cur = head;
    	// 第一次遍历
        while (cur != null) {
            ++n;
            cur = cur.next;
        }
        int k = 0;
        cur = head;
    	// 第二次遍历
        while (k < n / 2) {
            ++k;
            cur = cur.next;
        }
        return cur;
}
````

