[TOC]

### 一  栈数据结构

关于 **栈** ，类似一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。**后进者先出，先进者后出，这就是典型的“栈”结构。**

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/3e20cca032c25168d3cc605fa7a53a0b.jpg" alt="img" style="zoom:50%;" />

**当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构**。

### 二  如何实现一个“栈”？

从栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，我们来看一看如何用代码实现一个栈。

实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，我们叫作**链式栈**。

我这里实现一个基于数组的顺序栈：

````java
// 基于数组实现的顺序栈
public class ArrayStack {
	private String[] items;  // 数组
	private int count;       // 栈中元素个数
	private int n;           // 栈的大小

	// 初始化数组，申请一个大小为n的数组空间
	public ArrayStack(int n) {
		this.items = new String[n];
		this.n = n;
		this.count = 0;
	}

	// 入栈操作
	public boolean push(String item) {
		// 数组空间不够了，直接返回false，入栈失败。
		if (count == n) return false;
		// 将item放到下标为count的位置，并且count加一
		items[count] = item;
		++count;
		return true;
	}
  
	// 出栈操作
	public String pop() {
		// 栈为空，则直接返回null
		if (count == 0) return null;
		// 返回下标为count-1的数组元素，并且栈中元素个数count减一
		String tmp = items[count-1];
		--count;
		return tmp;
	}
}
````

不管是顺序栈还是链式栈，我们存储数据只需要一个大小为n的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)。

注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

### 三  支持动态扩容的顺序栈

刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。那我们如何基于数组实现一个可以支持动态扩容的栈呢？

你还记得，我们在数组那一节，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。

所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/b193adf5db4356d8ab35a1d32142b3da.jpg" alt="img" style="zoom:50%;" />

### 四  栈的应用

#### 1  栈在函数调用中的应用

栈作为一个比较基础的数据结构，比较经典的一个应用场景就是**函数调用栈**。

我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。

````java
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
````

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/17b6c6711e8d60b61d65fb0df5559a1c.jpg" alt="img" style="zoom:50%;" />

#### 2  栈在表达式求值中的应用

为了方便解释，将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较：

- 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；
- 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

我将3+5*8-6这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。

<img src="http://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/bc77c8d33375750f1700eb7778551600.jpg" alt="img" style="zoom:50%;" />

#### 3  栈在括号匹配中的应用

除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。

我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？

这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串：

- 当扫描到左括号时，则将其压入栈中；
- 当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。
- 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

#### 4  如何实现浏览器的前进、后退功能。

其实，用两个栈就可以非常完美地解决这个问题。我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。

比如你顺序查看了a，b，c三个页面，我们就依次把a，b，c压入栈，这个时候，两个栈的数据就是这个样子：

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/4b579a76ea7ebfc5abae2ad6ae6a3c3d.jpg" alt="img" style="zoom:33%;" />

当你通过浏览器的后退按钮，从页面c后退到页面a之后，我们就依次把c和b从栈X中弹出，并且依次放入到栈Y。这个时候，两个栈的数据就是这个样子：

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/ea804125bea25d25ba467a51fb98c4bc.jpg" alt="img" style="zoom:33%;" />

### 五  栈相关算法

#### 1 [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。

- 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。


````java
public boolean isValid(String s) {
        // 边界条件判断
        if ("".equals(s)){
            return true;
        }
        if (s == null || s.length() == 1) {
            return false;
        }
        // 用map保存所有的括号
        Map<Character,Character> maps = new HashMap<>();
        maps.put('(',')');
        maps.put('{','}');
        maps.put('[',']');
        // 使用栈实现，如有遇见左括号，则入栈，是右括号，则出栈
        Stack<Character> characterStack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (maps.containsKey(s.charAt(i))) {
                // 如果是左括号，则入栈
                characterStack.push(s.charAt(i));
            } else if (maps.containsValue(s.charAt(i))) {
                // 如果是右括号，判断栈是否为空，为空则false
                if (characterStack.empty()){
                    return false;
                }
                // 栈不为空，则出栈并删除，判断是否匹配
                Character left = characterStack.pop();
                if (!maps.containsKey(left) || maps.get(left) != s.charAt(i)) {
                    return false;
                }
            }else {
                return false;
            }
        }
        return characterStack.empty();
}
````

#### 2  [最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

````
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
````

````java
class MinStack {

    // 定义一个辅助栈，用来保存当前最小值
    Stack<Integer> minStack = new Stack<>();

    // 主栈
    Stack<Integer> mainStack = new Stack<>();

    /** initialize your data structure here. */
    public MinStack() {

    }
    
    // 插入操作
    public void push(int x) {
        // 首先在主栈中插入
        mainStack.push(x);
        // 如果最小栈为空，或者插入的元素小于等于最小栈的栈顶元素，则也插入到最小栈中
        if (minStack.size() == 0 || x <= minStack.peek()){
            minStack.push(x);
        }
    }
    
    // 弹出元素
    public void pop() {
        // 首先从主栈中弹出
        int x = mainStack.pop();
        // 如果弹出的元素等于当前最小栈的栈顶元素，则弹出最小栈的栈顶
        if (minStack.peek() == x){
            minStack.pop();
        }
    }
    
    public int top() {
        return mainStack.peek();
    }
    
    // 获取最小元素
    public int getMin() {
        // 最小栈的栈顶元素即最小元素
        if (minStack.size() > 0){
            return minStack.peek();
        }
        return 0;
    }
}

````

#### 3  [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

- void push(int x) 将元素 x 推到队列的末尾
- int pop() 从队列的开头移除并返回元素
- int peek() 返回队列开头的元素
- boolean empty() 如果队列为空，返回 true ；否则，返回 false


说明：

你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

````java
class MyQueue {

    // 使用两个栈
    private Stack<Integer> leftStack = new Stack<>();
    private Stack<Integer> rightStack = new Stack<>();
    /** Initialize your data structure here. */
    public MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        // 入队只会在leftStack中
        leftStack.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        // 如果rightStack不为空，则直接弹出right中的元素
        if (!rightStack.empty()){
            return rightStack.pop();
        }
        // 如果right中为空，则先把left中的元素全部弹出到right中，再出栈
        while (!leftStack.empty()){
            rightStack.push(leftStack.pop());
        }
        return rightStack.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        // 查看元素操作和pop一样
        if (!rightStack.empty()){
            return rightStack.peek();
        }
        while (!leftStack.empty()){
            rightStack.push(leftStack.pop());
        }
        return rightStack.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        // 两个栈都为空才是空
        return leftStack.empty() && rightStack.empty();
    }
}
````

#### 4  [比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

示例 1：

````
输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
````

示例 2：

````
输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
````

**1  使用栈：**

````java
public boolean backspaceCompare(String S, String T) {
        Stack<Character> s1 = new Stack<>();
        Stack<Character> s2 = new Stack<>();
        for (Character character : S.toCharArray()){
            // 如果是#号，则出栈，否则入栈
            if (character.equals('#')){
                if (!s1.empty()){
                    s1.pop();
                }
            }else {
                s1.push(character);
            }
        }
        for (Character character : T.toCharArray()){
            if (character.equals('#')){
                if (!s2.empty()){
                    s2.pop();
                }
            }else {
                s2.push(character);
            }
        }
        if (s1.size() != s2.size()){
            return false;
        }
        while (!s1.empty()){
            if (!s1.pop().equals(s2.pop())){
                return false;
            }
        }
        return true;
    }
````

**2  重构字符串**

````java
 public boolean backspaceCompare(String S, String T) {
        return build(S).equals(build(T));
    }

    public String build(String str) {
        StringBuffer ret = new StringBuffer();
        int length = str.length();
        for (int i = 0; i < length; ++i) {
            char ch = str.charAt(i);
            // 不为#，则加入到新串中
            if (ch != '#') {
                ret.append(ch);
            } else {
                if (ret.length() > 0) {
                    ret.deleteCharAt(ret.length() - 1);
                }
            }
        }
        return ret.toString();
    }
````

#### 5  [基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号 `(` ，右括号 `)`，加号 `+` ，减号 `-`，**非负**整数和空格 ` `。

示例 1:

````
输入: "1 + 1"
输出: 2
````

示例 2:

````
输入: " 2-1 + 2 "
输出: 3
````

示例 3:

````
输入: "(1+(4+5+2)-3)+(6+8)"
输出: 23
````

````java
// TODO

````

#### 6  [棒球比赛](https://leetcode-cn.com/problems/baseball-game/)

你现在是一场采特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

1. 整数 x - 表示本回合新获得分数 x

2. "+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。

3. "D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。

4. "C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。

请你返回记录中所有得分的总和。

示例 1：

````
输入：ops = ["5","2","C","D","+"]
输出：30
解释：
"5" - 记录加 5 ，记录现在是 [5]
"2" - 记录加 2 ，记录现在是 [5, 2]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
所有得分的总和 5 + 10 + 15 = 30
````

示例 2：

````
输入：ops = ["5","-2","4","C","D","9","+","+"]
输出：27
解释：
"5" - 记录加 5 ，记录现在是 [5]
"-2" - 记录加 -2 ，记录现在是 [5, -2]
"4" - 记录加 4 ，记录现在是 [5, -2, 4]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
````

````java
// TODO
````



#### 7 [下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

示例 1:

````
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
````

示例 2:

````
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
````

````java
// TODO

````

