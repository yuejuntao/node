[TOC]



#### 一  如何理解**“**递归**”**？ 

从我⾃⼰学习数据结构和算法的经历来看，我个⼈觉得，有两个最难理解的知识点，⼀个是动态规划，另⼀个就是递归。 

递归是⼀种应⽤⾮常⼴泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要⽤到递归，⽐如DFS深度优先搜索、前中后序⼆叉树遍历等等。所以，搞懂递归⾮常重要，否则，后⾯复杂⼀些的数据结构和算法学起来就会⽐较吃⼒。 

不过，别看我说了这么多，递归本身可是⼀点⼉都不“⾼冷”，咱们⽣活中就有很多⽤到递归的例⼦。 

周末你带着⼥朋友去电影院看电影，⼥朋友问你，咱们现在坐在第⼏排啊？电影院⾥⾯太⿊了，看不清，没法数，现在你怎么办？

别忘了你是程序员，这个可难不倒你，递归就开始排上⽤场了。于是你就问前⾯⼀排的⼈他是第⼏排，你想只要在他的数字上 加⼀，就知道⾃⼰在哪⼀排了。但是，前⾯的⼈也看不清啊，所以他也问他前⾯的⼈。就这样⼀排⼀排往前问，直到问到第⼀ 排的⼈，说我在第⼀排，然后再这样⼀排⼀排再把数字传回来。直到你前⾯的⼈告诉你他在哪⼀排，于是你就知道答案了。 

这就是⼀个⾮常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以⽤递推公式来表示。刚刚这个⽣活中的例⼦，我们⽤递推公式将它表示出来就是这样的： 

````java
f(n)=f(n-1)+1  // 其中，f(1)=1
````

f(n)表示你想知道⾃⼰在哪⼀排，f(n-1)表示前⾯⼀排所在的排数，f(1)=1表示第⼀排的⼈知道⾃⼰在第⼀排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下： 

````java
int f(int n) { 
    if (n == 1) return 1; 
    return f(n-1) + 1; 
}
````

#### 二  递归需要满⾜的三个条件 

刚刚这个例⼦是⾮常典型的递归，那究竟什么样的问题可以⽤递归来解决呢？我总结了三个条件，只要同时满⾜以下三个条件，就可以⽤递归来解决。 

##### 1  ⼀个问题的解可以分解为⼏个⼦问题的解 

何为⼦问题？⼦问题就是数据规模更⼩的问题。⽐如，前⾯讲的电影院的例⼦，你要知道，“⾃⼰在哪⼀排”的问题，可以分解为“前⼀排的⼈在哪⼀排”这样⼀个⼦问题。 

##### 2  这个问题与分解之后的⼦问题，除了数据规模不同，求解思路完全⼀样 

⽐如电影院那个例⼦，你求解“⾃⼰在哪⼀排”的思路，和前⾯⼀排⼈求解“⾃⼰在哪⼀排”的思路，是⼀模⼀样的。 

##### 3  存在递归终⽌条件

把问题分解为⼦问题，把⼦问题再分解为⼦⼦问题，⼀层⼀层分解下去，不能存在⽆限循环，这就需要有终⽌条件。 

还是电影院的例⼦，第⼀排的⼈不需要再继续询问任何⼈，就知道⾃⼰在哪⼀排，也就是f(1)=1，这就是递归的终⽌条件。 

#### 三  如何编写递归代码（爬台阶问题）

刚刚铺垫了这么多，现在我们来看，如何来写递归代码？我个⼈觉得，写递归代码最关键的是写出递推公式，找到终⽌条件，剩下将递推公式转化为代码就很简单了。 

你先记住这个理论。我举⼀个例⼦，带你⼀步⼀步实现⼀个递归代码，帮你理解。假如这⾥有n个台阶，每次你可以跨1个台阶或者2个台阶，请问⾛这n个台阶有多少种⾛法？如果有7个台阶，你可以2，2，2，1这样⼦上去，也可以1，2，1，1，2这样⼦上去，总之⾛法有很多，那如何⽤编程求得总共有多少种⾛法呢？ 

我们仔细想下，实际上，可以根据第⼀步的⾛法把所有⾛法分为两类：

- 第⼀类是第⼀步⾛了1个台阶

- 另⼀类是第⼀步⾛了2个台阶

所以n个台阶的⾛法就等于先⾛1阶后，n-1个台阶的⾛法加上先⾛2阶后，n-2个台阶的⾛法。⽤公式表示就是： 
$$
f(n) = f(n-1)+f(n-2)
$$
有了递推公式，递归代码基本上就完成了⼀半。我们再来看下终⽌条件。当有⼀个台阶时，我们不需要再继续递归，就只有⼀ 种⾛法。所以f(1)=1。这个递归终⽌条件⾜够吗？我们可以⽤n=2，n=3这样⽐较⼩的数试验⼀下。 

n=2时，f(2)=f(1)+f(0)。如果递归终⽌条件只有⼀个f(1)=1，那f(2)就⽆法求解了。所以除了f(1)=1这⼀个递归终⽌条件外，还要有f(0)=1，表示⾛0个台阶有⼀种⾛法，不过这样⼦看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为⼀种终⽌条件，表示⾛2个台阶，有两种⾛法，⼀步⾛完或者分两步来⾛。 

所以，递归终⽌条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3，n=4来验证⼀下，这个终⽌条件是否⾜够并且正确。 

我们把递归终⽌条件和刚刚得到的递推公式放到⼀起就是这样的： 

````java
f(1) = 1; 
f(2) = 2; 
f(n) = f(n-1)+f(n-2)
````

有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的： 

````java
int f(int n) { 
    if (n == 1) return 1; 
    if (n == 2) return 2; 
    return f(n-1) + f(n-2); 
}
````

我总结⼀下，写递归代码的关键就是找到如何将⼤问题分解为⼩问题的规律，并且基于此写出递推公式，然后再推敲终⽌条件，最后将递推公式和终⽌条件翻译成代码。 

虽然我讲了这么多⽅法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是⽂章开头我说递归代码⽐较难理解的地⽅。 

刚讲的电影院的例⼦，我们的递归调⽤只有⼀个分⽀，也就是说“⼀个问题只需要分解为⼀个⼦问题”，我们很容易能够想清楚“递“和”归”的每⼀个步骤，所以写起来、理解起来都不难。 

但是，当我们⾯对的是⼀个问题要分解为多个⼦问题的情况，递归代码就没那么好理解了。 

像我刚刚讲的第⼆个例⼦，⼈脑⼏乎没办法把整个“递”和“归”的过程⼀步⼀步都想清楚。 

计算机擅⻓做重复的事情，所以递归正和它的胃⼝。⽽我们⼈脑更喜欢平铺直叙的思维⽅式。当我们看到递归时，我们总想把 

递归平铺展开，脑⼦⾥就会循环，⼀层⼀层往下调，然后再⼀层⼀层返回，试图想搞清楚计算机每⼀步都是怎么执⾏的，这样就很容易被绕进去。

对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进⼊了⼀个思维误区。很多时候，我们理解起来⽐较吃⼒， 主要原因就是⾃⼰给⾃⼰制造了这种理解障碍。那正确的思维⽅式应该是怎样的呢？ 

````
如果⼀个问题A可以分解为若⼲⼦问题B、C、D，你可以假设⼦问题B、C、D已经解决，在此基础上思考如何解决问题A。⽽且，你只需要思考问题A与⼦问题B、C、D两层之间的关系即可，不需要⼀层⼀层往下思考⼦问题与⼦⼦问题，⼦⼦问题与⼦⼦⼦问题之间的关系。屏蔽掉递归细节，这样⼦理解起来就简单多了。 
````

因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成⼀个递推公式，不⽤想⼀层层的调⽤关系，不要试图⽤⼈脑去分解递归的每个步骤。 

#### 四  递归代码注意事项

##### 1  递归代码要警惕堆栈溢出 

在实际的软件开发中，编写递归代码时，我们会遇到很多问题，⽐如堆栈溢出。⽽堆栈溢出会造成系统性崩溃，后果会⾮常严重。为什么递归代码容易造成堆栈溢出呢？我们⼜该如何预防堆栈溢出呢？ 

我在“栈”那⼀节讲过，函数调⽤会使⽤栈来保存临时变量。每调⽤⼀个函数，都会将临时变量封装为栈帧压⼊内存栈，等函数执⾏完成返回时，才出栈。系统栈或者虚拟机栈空间⼀般都不⼤。如果递归求解的数据规模很⼤，调⽤层次很深，⼀直压⼊栈，就会有堆栈溢出的⻛险。 

⽐如前⾯的讲到的电影院的例⼦，如果我们将系统栈或者JVM堆栈⼤⼩设置为1KB，在求解f(19999)时便会出现如下堆栈报错

````java
Exception in thread "main" java.lang.StackOverflowError
````

那么，如何避免出现堆栈溢出呢？我们可以通过在代码中限制递归调⽤的最⼤深度的⽅式来解决这个问题。

递归调⽤超过⼀定深度（⽐如1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例⼦，我们可以改造成下⾯这样⼦，就可以避免堆栈溢出了。不过，我写的代码是伪代码，为了代码简洁，有些边界条件没有考虑，⽐如x<=0。 

````java
// 全局变量，表示递归的深度。 
int depth = 0; 
int f(int n) { 
    ++depth; 
    // 如果达到限制的深度，则抛出异常
    if (depth > 1000) {
    	throw exception;   
    } 
    if (n == 1){
    	return 1;  
    }
    return f(n-1) + 1; 
}
````

但这种做法并不能完全解决问题，因为最⼤允许的递归深度跟当前线程剩余的栈空间⼤⼩有关，事先⽆法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最⼤深度⽐较⼩，⽐如10、50，就可以⽤这种⽅法，否则这种⽅法并不是很实⽤。

##### 2  递归代码要警惕重复计算（优化爬台阶问题）

除此之外，使⽤递归时还会出现重复计算的问题。刚才我讲的第⼆个递归代码的例⼦，如果我们把整个递归过程分解⼀下的话，那就是这样的

<img src="https://raw.githubusercontent.com/yuejuntao/typoraImg/master/img/image-20201130111107831.png" alt="image-20201130111107831" style="zoom:33%;" />

从图中，我们可以直观地看到，想要计算f(5)，需要先计算f(4)和f(3)，⽽计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，这就是重复计算问题。 

为了避免重复计算，我们可以通过⼀个数据结构（⽐如散列表）来保存已经求解过的f(k)。当递归调⽤到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。 

爬台阶问题可以优化为如下代码：

````java
// hasSolvedList可以理解成⼀个Map，key是n，value是f(n) 
Map<Integer,Integer> hasSolvedList = new HashMap<>();
public int f(int n) { 
    if (n == 1) return 1; 
    if (n == 2) return 2; 
    // 如果map中存在n，表示n已经计算过了，不需要重复计算
    if (hasSolvedList.containsKey(n)) { 
        return hasSovledList.get(n); 
    }
    int ret = f(n-1) + f(n-2); 
    // 把n的计算结果保存到map里
    hasSovledList.put(n, ret); 
    return ret; 
}
````

除了堆栈溢出、重复计算这两个常⻅的问题。递归代码还有很多别的问题。 

在时间效率上，递归代码⾥多了很多函数调⽤，当这些函数调⽤的数量较⼤时，就会积聚成⼀个可观的时间成本。在空间复杂度上，因为递归调⽤⼀次就会在内存栈中保存⼀次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，⽐如我们前⾯讲到的电影院递归代码，空间复杂度并不是O(1)，⽽是O(n)。 

#### 五  怎么将递归代码改写为⾮递归代码？（转换爬楼梯问题）

我们刚说了，递归有利有弊，利是递归代码的表达⼒很强，写起来⾮常简洁；⽽弊就是空间复杂度⾼、有堆栈溢出的⻛险、存在重复计算、过多的函数调⽤会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要⽤递归的⽅式来实现。 

那我们是否可以把递归代码改写为⾮递归代码呢？⽐如刚才那个电影院的例⼦，我们抛开场景，只看f(x) =f(x-1)+1这个递推公式。我们这样改写看看： 

````java
int f(int n) { 
    int ret = 1; 
    for (int i = 2; i <= n; ++i) { 
        ret = ret + 1; 
    }
    return ret; 
}
````

爬台阶问题可以转换为如下非递归代码：

````java
int f(int n) { 
    if (n == 1) return 1; 
    if (n == 2) return 2; 
    // 计算结果
    int ret = 0;
    // 由于fib(n)的值只和fib(n-1)和fib(n-2)有关，所以只需要两个变量保存这两个值即可，减少了空间复杂度
    // 使用两个变量保存前一个和前前一个值
    // 前一个值
    int pre = 2;
    // 前前一个值
    int prepre = 1; 
    // 遍历
    for (int i = 3; i <= n; ++i) { 
        ret = pre + prepre; 
        prepre = pre; 
        pre = ret; 
    }
    return ret; 
}
````

#### 六  问题扩散

##### 1  青蛙跳台阶问题

```java
一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 
```

问题解析：

跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么f(n-1) = f(n-2) + f(n-3) + ... + f(0) 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从n-2 级跳 2 级上去... ，那么 f(n) = f(n-1) + f(n-2) + ... + f(0) 

综上可得

f(n) - f(n-1) = f(n-1) 即 f(n) = 2*f(n-1) 所以 f(n) 是一个等比数列 0,1,2,4,8

````java
	public int fibonacci3(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int temp = 1;
        for (int i = 2; i <= n; i++) {
            temp = 2 * temp;
        }
        return temp;
    }
````

